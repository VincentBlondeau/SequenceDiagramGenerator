<?xml version="1.0"?><st-source><!-- Name: SequenceDiagramGeneratorBundleName: SequenceDiagramGeneratorBundleStructure: a Store.BundleForParcelComment: This packge is meant to be released in https://github.com/VincentBlondeau/SequenceDiagramGenerator under MIT licenceParcel: #('SequenceDiagramGenerator')ParcelName: SequenceDiagramGeneratorDate: 10:55:17 am November 20, 2018 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on November 20, 2018 at 10:55:17 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Pharo</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BasicFeatures</category><attributes><package>PharoKernelAdditionsPkg</package></attributes></name-space><name-space><name>SUnit</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>SUnitToo</package></attributes></name-space><name-space><name>LAN</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Lan</category><attributes><package>LANModel</package></attributes></name-space><name-space><name>SequenceDiagram</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></name-space><class><name>TestResourceUnavailable</name><environment>SUnit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResourceUnavailable</class-id><body>Raised when we can't get a TestResource initialized.</body></comment><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestCase</class-id><body>A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.UsageWhen you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override #tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.Implementation	See also TestResource comment. When a test is prepared to run, they are usually grouped by their response to resources. The result of the #resources query is a deterministic vector of TestResources to run that specific test. In all cases, when a TestResource is called out by a Test, that Resource's own Resources will precede it. The order of query for a TestCase is first the class side #resources method. After that, any class side &lt;resource&gt; tagged methods are visited. They are visited alphabetically, class by class, up the inheritance change. Finally, any method local resources are added.Instance Variables	testSelector	&lt;Symbol&gt;	which method represents the current test</body></comment><class><name>BlockNodeProbe</name><environment>SequenceDiagram</environment><super>CraftedSmalltalk.DisplayActionProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>otherProbe </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>FMMultivalueLink</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values owner opposite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FameMultivalueLinksPkg</category><attributes><package>FameMultivalueLinksPkg</package></attributes></class><class><name>MethodWrapper</name><environment>Smalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MethodWrappersApp</category><attributes><package>MethodWrappersApp</package></attributes></class><comment><class-id>MethodWrapper</class-id><body>MethodWrappers can add "hidden" behavior to the ordinary method. They can change what is executed before or after the method. For example, a CountMethodWrapper would increment a counter when the method is called, and then forward the call onto the original method. While this class is not abstract (i.e., there are no subclassResponsibilities), these method wrappers don't do anything if you install them. Look at the subclasses for example uses.To create a new type of method wrapper, you must create a subclass of MethodWrapper and redefine the #beforeMethod and/or #afterMethod as necessary. If you only need to redefine the #beforeMethod, you can redefine the #valueFrom:arguments: method instead (see the CountMethodWrapper). This will give you some added performance since it doesn't need to create two blocks and send the #valueNowOrOnUnwindDo: message.To use a method wrapper, send the class a #on:inClass message. This will return a new method wrapper (or nil if this method shouldn't be wrapped). You can then install the method wrapper by sending the #install message and uninstall by sending the #uninstall message.WARNING: incorrectly using the wrappers can crash your image, so you should save your image before using them. Most problems occur as a result of installing them on methods that are called either in the #beforeMethod or #afterMethod. (Note: the #value method in Association (VariableBinding in VW2.5) is automatically called by the VM when you refer to a global, class, or pool variable so you should probably never wrap it. I advise against wrapping primitives also.)Instance Variables:clientMethod	&lt;CompiledMethod&gt;	the method that is being wrappedselector	&lt;Symbol&gt;	the selector that the method is listed under in the method dictionaryClass Instance Variables:methods	&lt;OrderedCollection of: MethodWrapper&gt;	prototype wrappers that are copied when installing new wrappers</body></comment><class><name>MethodWrapperCompiler</name><environment>Smalltalk</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MethodWrappersApp</category><attributes><package>MethodWrappersApp</package></attributes></class><comment><class-id>MethodWrapperCompiler</class-id><body>The MethodWrapperCompiler is a special compiler that is parameterized by the class of method to create. It is used to compile specific types of wrappers.Instance Variables:methodClass	&lt;Behavior&gt;	the class of the method that will be created</body></comment><class><name>JumpFinder</name><environment>SequenceDiagram</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pcToFind found jumpId loopHeads </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Node</name><environment>LAN</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name nextNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>Object</name><environment>Pharo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BasicFeatures</category><attributes><package>PharoKernelAdditionsPkg</package></attributes></class><class><name>LoopPath</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path currentPathIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>ActivationCasesPossibilities</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activationsPossibilities switch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>PackagePrerequisitesComputerTest</name><environment>SequenceDiagram</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagramTest</package></attributes></class><class><name>TestResourceError</name><environment>SUnit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failingResource resourceSet originalException </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResourceError</class-id><body>Raised when any Error occurs during TestResource handling. This is distinct from a ResourceUnavailableError.</body></comment><class><name>SequenceDiagramModelTest</name><environment>SequenceDiagram</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagramTest</package></attributes></class><class><name>SequenceDiagramTest</name><environment>SequenceDiagram</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagramTest</package></attributes></class><class><name>Instance</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clazz activationsCreated activationsReceived instanceId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>ActivationSwitch</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cases currentCaseIdx preferedIdx </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><comment><class-id>SequenceDiagram.ActivationSwitch</class-id><body>The following comment was cloned from the original comment of ActivationCase==========================================================</body></comment><class><name>FailedAssertion</name><environment>SUnit</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPreload</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.FailedAssertion</class-id><body>I am raised when an assert: fails to pass.</body></comment><class><name>ClassA</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bool lan </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagramTestResources</category><attributes><package>SequenceDiagramTestResources</package></attributes></class><class><name>BlockNodeProbeEditor</name><environment>SequenceDiagram</environment><super>CraftedSmalltalk.DisplayProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionEditor availablePackages packageAvailability selectedPackages fileName disturbed transformerCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SequenceDiagram</package></attributes></class><class><name>OutputServer</name><environment>LAN</environment><super>LAN.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>FileServer</name><environment>LAN</environment><super>LAN.OutputServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>PrintServer</name><environment>LAN</environment><super>LAN.OutputServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>SequenceDiagramCreator</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages instrumentedMethods instanceId modelHolder blockExecutionResult </inst-vars><class-inst-vars>InstancesDict </class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagramWriter</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>FMMultiMultivalueLink</name><environment>Smalltalk</environment><super>FMMultivalueLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FameMultivalueLinksPkg</category><attributes><package>FameMultivalueLinksPkg</package></attributes></class><class><name>ActivationCase</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activations switch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>PackagePrerequisitesComputer</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>initialPackages depth excludesNames prereqs excludesPkg </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><comment><class-id>SequenceDiagram.PackagePrerequisitesComputer</class-id><body>I compute the dependencies of the packages in my arguments. I am strongly inspired of the code in DeploymentPrerequisitesTool that is unfortunatly not modulable and not usable as is...Instance Variables:	depth	&lt;CTROCProxy | CWMinimalObject | MessageForwarder | Object | ProtoObject | Proxy | Proxy&gt;	description of depth	excludesNames	&lt;CTROCProxy | CWMinimalObject | MessageForwarder | Object | ProtoObject | Proxy | Proxy&gt;	description of excludesNames	initialPackageNames	&lt;CTROCProxy | CWMinimalObject | MessageForwarder | Object | ProtoObject | Proxy | Proxy&gt;	description of initialPackageNames</body></comment><class><name>LANInterface</name><environment>LAN</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeName nodeList nextNode deviceNameMenu contents originator addressee </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><comment><class-id>LAN.LANInterface</class-id><body>LAN Interface comments for testing purposes.Instance Variables:	addressee	&lt;ValueHolder&gt;	description of addressee	contents	&lt;ValueHolder&gt;	description of contents	deviceNameMenu	&lt;ValueModel&gt;	description of deviceNameMenu	nextNode	&lt;ValueHolder&gt;	description of nextNode	nodeList	&lt;SelectionInList&gt;	description of nodeList	nodeName	&lt;ValueHolder&gt;	description of nodeName	originator	&lt;ValueHolder&gt;	description of originator</body></comment><class><name>MethodWrappersApp</name><environment>Smalltalk</environment><super>Application</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MethodWrappersApp</category><attributes><package>MethodWrappersApp</package></attributes></class><class><name>Activation</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method creator receiver senderActivation engendredActivation direction loopId pcId process </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>ActivationLoop</name><environment>SequenceDiagram</environment><super>SequenceDiagram.Activation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activations lastPc isFull counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>AbstractDestinationAddress</name><environment>LAN</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>SingleDestinationAddress</name><environment>LAN</environment><super>LAN.AbstractDestinationAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>TestResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResource</class-id><body>I am a singleton pattern, used to provide common long lived resources across a series of test runs.OverviewTestResources can be used to alleviate expensive resource setup for series of tests. For example, your tests may require a database connection. Reconnecting for each test, may be overly expensive, and better done just once for all of the tests.UsageCreate a subclass of me, if you want to make your own test resource. A resource is managed as a singleton. When it is activated, if necessary, it instantiates and stores in the 'current' class instance variable. The message #setUp is sent to the instance. When a suite is done, it will release the resource by sending #reset to the class, which in turn sends #tearDown to the singleton.Code in a TestCase test method then usually access the resource via a YourTestResourceClass current sendSomeMethodToItTo register your TestResource with a TestCase, you have three choices:1) Implement the message #resources on the class side of your TestCase. It should return a collection of TestResource classes.2) Add an arbitrarily named class side message to your TestCase, use the method tag &lt;resource&gt; to indicate it participates in the TestResource search. It should return a nil, a TestResourceClass, or a collection of TestResource classes.In both of the cases above, while it is common to just return a hard coded value, if your needs are more dynamic, you can certainly make computations before returning the result.3) You can have a resource for a specific test case, by using the method tag &lt;uses: #YourTestResourceClassName&gt; in your test method. You may use either a symbol, or  binding reference.Finally, a TestResource may drag other TestResources into the picture by specifying via its class side #resources method additional resource required by the receiver.</body></comment><class><name>AbstractEntity</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name realObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Package</name><environment>SequenceDiagram</environment><super>SequenceDiagram.AbstractEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Method</name><environment>SequenceDiagram</environment><super>SequenceDiagram.AbstractEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clazz activations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Packet</name><environment>LAN</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents addressee originator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>TestSuite</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourceAndDefinitions </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestSuite</class-id><body>This is a Composite of Tests. After building one, use #run to run the tests, or runUsing: [:eachTestCase | ] to have more control over how each test is run.ImplementationOn the outside, a suite is a big bag of tests. Under the hood, it actually aggregates tests by their resources. And when it then runs them, it manages the logic of bring the resources alive and shutting them down. To avoid thrashing resource startup/shutdown overhead, and to avoid contention between competing resources, it stores and executes them by resources.Unlike SUnit, it is the suite that assumes the responsibility of enumerating the individual tests (not the Results). So if one wants to change the way tests are enumerated, or how they are run, one should consider making a subclass of TestSuite, not Results.In SUnitToo, Suites do NOT gather the results. Rather you register with TestCase class to receive announcements as the results are reported. Results is an example/reference implementation of how one does that.Instance Variables	resources	&lt;Collection of &gt;	collection of test resources	tests	&lt;Dictionary of: ((IdentitySet of: TestResource) -&gt; (IdentitySet of: MethodDefinition))&gt;	method definitions for all the tests to run; we take advantage of the fact that we can create definitions for inherited test implementations. Using MethodDefinitions, rather than the tests themselves, avoids memory leak problems. The definitions are grouped in collections, keyed by collections of the TestResources that go with them</body></comment><class><name>SequenceDiagramAbstractModelTransformer</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modelHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagramModelTransformerResetInstanceNumbers</name><environment>SequenceDiagram</environment><super>SequenceDiagram.SequenceDiagramAbstractModelTransformer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagramModelTransformerUniqueInstance</name><environment>SequenceDiagram</environment><super>SequenceDiagram.SequenceDiagramAbstractModelTransformer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagramModelTransformerFilter</name><environment>SequenceDiagram</environment><super>SequenceDiagram.SequenceDiagramAbstractModelTransformer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagramModelTransformerLoopCondenser</name><environment>SequenceDiagram</environment><super>SequenceDiagram.SequenceDiagramAbstractModelTransformer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result state loopPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>SequenceDiagram</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transformers block packages stream seqDiagramCreator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Class</name><environment>SequenceDiagram</environment><super>SequenceDiagram.AbstractEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instances methods package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Results</class-id><body>Results is an example/reference implementation of a result gathering mechanism. It simply records each Result in the appropriate bucket.UsageBecause the Result observes a universal object, Results can run in parallel. And different Result observers can take different kind of actions. Examples have included, interactive feedback, storing information for browser annotation, a variety of custom loggers logging different kinds of details, and coverage tracking gatherers.ImplementationAt its core, a Results is an Announcement observer. Every time a TestCase is run, the TestCase *class* posts an announcement with the result of the test. A results gatherer then, just has to observer the Result anouncement being broadcast from the TestCase class. This is done with the collectWhile: method.Instance Variables	errors	&lt;Set&gt;		failures	&lt;Set&gt;		passes	&lt;Set&gt;	</body></comment><class><name>WorkStation</name><environment>LAN</environment><super>LAN.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LanApp</category><attributes><package>LANModel</package></attributes></class><class><name>SequenceDiagramLoopTest</name><environment>SequenceDiagram</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theItemThatIsInTheLoop theItemThatIsAfterTheSwitch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SequenceDiagram</category><attributes><package>SequenceDiagramTest</package></attributes></class><class><name>SequenceDiagramModelHolder</name><environment>SequenceDiagram</environment><super>Pharo.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activations instances classes methods semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SequenceDiagram</package></attributes></class><class><name>TestCaseAnnouncement</name><environment>SUnit</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestCaseAnnouncement</class-id><body>The following comment was copied from the original comments of SUnit.Result==========================================================Each test run results in one of my subclasses being announced as the result of the test run. I have protocol for halping to qualify myself, and get at the test case for which I was run.Subclasses must implement the following messages:	accessing		addTo:Instance Variables:	definition	&lt;MethodDefinition&gt;	a definiton used to describe (indirectly) the test that was run to get this result</body></comment><class><name>Started</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Result</class-id><body>Each test run results in one of my subclasses being announced as the result of the test run. I have protocol for halping to qualify myself, and get at the test case for which I was run.Subclasses must implement the following messages:	accessing		addTo:Instance Variables:	definition	&lt;MethodDefinition&gt;	a definiton used to describe (indirectly) the test that was run to get this result</body></comment><class><name>ExceptionalResult</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.ExceptionalResult</class-id><body>A generic announcement for any kind of test result that is unexpected, and for which we'd like to be able to retain exception information.Instance Variables:	exception	&lt;Exception&gt;	the exception that was associatied with generating this result</body></comment><class><name>Failure</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Failure</class-id><body>I'm used to announce that a FailedAssertion occured.</body></comment><class><name>SomeError</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.SomeError</class-id><body>Announcement to indicate  an Error occured while running the test.</body></comment><class><name>Pass</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Pass</class-id><body>I'm the result that is announced when a test method is run successfully with no exceptions occuring.</body></comment><shared-variable><name>MySubscriptions</name><environment>SUnit.TestCase</environment><private>false</private><constant>false</constant><category>subscriptions</category><initializer></initializer><attributes><package>SUnitToo</package></attributes></shared-variable><shared-variable><name>InstanceIdCounter</name><environment>SequenceDiagram.Instance</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>1</initializer><attributes><package>SequenceDiagram</package></attributes></shared-variable><methods><class-id>SUnit.TestResourceUnavailable</class-id> <category>accessing</category><body package="SUnitToo" selector="resourceSet">resourceSet	^self parameter</body><body package="SUnitToo" selector="resourceSet:">resourceSet: aResourceSet	self parameter: aResourceSet</body></methods><methods><class-id>SUnit.TestResourceUnavailable class</class-id> <category>testing</category><body package="SUnitToo" selector="mayResume">mayResume	^true</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SUnitToo" selector="assert:description:">assert: aBoolean description: aString	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo" selector="assert:description:resumable:">assert: aBoolean description: aString resumable: resumableBoolean	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo" selector="assert:equals:">assert: anObject equals: anotherObject	self assert: anObject = anotherObject		description: anObject printString, ' is not equal to ', anotherObject printString.</body><body package="SUnitToo" selector="assertCollection:equals:">assertCollection: actual equals: expected	"Specialized test method that generates a proper error message for collection"	^ self		assert: expected = actual		description: [ self comparingCollectionBetween: actual and: expected ]</body><body package="SUnitToo" selector="assertCollection:hasSameElements:">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |		additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self 		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description: (String streamContents: 			[:stream |			stream				nextPutAll: 'Given Collections do not match!'; lf;				tab; nextPutAll: 'additions : '; print: additionalElements asArray; lf;				tab; nextPutAll: 'missing: '; print: missingElements asArray; lf ])</body><body package="SUnitToo" selector="comparingCollectionBetween:and:">comparingCollectionBetween: left and: right	| additionalLeft additionalRight sortBlock|		"use a very slow sort block"	sortBlock := [ :a :b | a asString &lt;= b asString ].	additionalLeft := (left difference: right) sorted: sortBlock.	additionalRight := (right difference: left) sorted: sortBlock. 		^ String streamContents: [:stream |		stream			nextPutAll: 'Given Collections do not match. Got '; lf;			tab; nextPutAll: 'left := '; print: left; nextPut: $.; lf;			nextPutAll: ' instead of ';			tab; nextPutAll: ' right :='; print: left; nextPut: $.; lf.		left size = right size			ifFalse: [ 				stream 					nextPutAll: 'Collection size does not match: left='; 					print: left size;					nextPutAll: ' vs. right=';					print: right size; lf ].		additionalLeft isEmpty			ifFalse: [ 				stream 					nextPutAll: 'Got ';					print: additionalLeft size;					nextPutAll: ' additional element(s) in the left collection: ';					tab; print: additionalLeft  ].		additionalRight isEmpty			ifFalse: [ 				stream 					nextPutAll: 'Got ';					print: additionalRight size;					nextPutAll: ' additional element(s) in the right collection: ';					tab; print: additionalRight  ]]</body><body package="SUnitToo" selector="deny:description:">deny: aBoolean description: aString	self assert: aBoolean not description: aString</body><body package="SUnitToo" selector="deny:description:resumable:">deny: aBoolean description: aString resumable: resumableBoolean	self assert: aBoolean not description: aString resumable: resumableBoolean</body><body package="SUnitToo" selector="should:raise:description:">should: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent)		description: aString.</body><body package="SUnitToo" selector="shouldnt:raise:description:">shouldnt: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent) not		description: aString.</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>comparing</category><body package="SUnitToo" selector="=">= aTestCase 	^self class == aTestCase class and: [testSelector == aTestCase selector]</body><body package="SUnitToo" selector="hash">hash	^testSelector hash bitXor: self class hash</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>accessing</category><body package="SUnitToo" selector="assert:">assert: aBoolean 	aBoolean ifFalse: [self signalFailure: 'Assertion failed']</body><body package="SUnitToo" selector="deny:">deny: aBoolean	self assert: aBoolean not</body><body package="SUnitToo" selector="fail">fail	^self assert: false</body><body package="SUnitToo" selector="fail:">fail: aDescriptionString	^self assert: false description: aDescriptionString</body><body package="SUnitToo" selector="method">method	^(self class findSelector: testSelector) ifNotNil: [:pair | pair last]</body><body package="SUnitToo" selector="resources">resources	"Compute all of the resources necessary for this specific test, avoid duplicates, but otherwise keep the order (depth first) (i.e. don't use a Set). Do not override this message. See the class comment for TestResource for instructions on how to add resources."	| resources |	resources := Array new.	resources := TestResource appendResources: self methodLocalResources to: resources.	resources := TestResource appendResources: self class allResources to: resources.	^resources</body><body package="SUnitToo" selector="selector">selector	^testSelector</body><body package="SUnitToo" selector="should:">should: aBlock	self assert: aBlock value</body><body package="SUnitToo" selector="should:raise:">should: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent)</body><body package="SUnitToo" selector="shouldnt:">shouldnt: aBlock	self deny: aBlock value</body><body package="SUnitToo" selector="shouldnt:raise:">shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent) not</body><body package="SUnitToo" selector="signalFailure:">signalFailure: aString 	FailedAssertion raiseSignal: aString</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>private</category><body package="SUnitToo" selector="assertBlock:raises:">assertBlock: aBlock raises: anExceptionalEvent 	^	[aBlock value.	false] on: anExceptionalEvent do: [:ex | ex return: true]</body><body package="SUnitToo" selector="methodLocalResources">methodLocalResources	| specificResources method classRef |	specificResources := #().	method := self asDefinition method.	method attributeMessages		ifNotNil: 			[:methodTags |			methodTags do: 					[:eachTag |					eachTag selector = #uses:						ifTrue: 							[classRef := eachTag arguments first.							classRef isSymbol								ifTrue: 									[classRef := BindingReference simpleName: classRef in: method environment].							classRef								ifDefinedDo: [:resource | specificResources := specificResources copyWith: resource]]]].	^specificResources</body><body package="SUnitToo" selector="performTest">performTest	self perform: testSelector</body><body package="SUnitToo" selector="setTestSelector:">setTestSelector: aSymbol 	testSelector := aSymbol asSymbol</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>announcements</category><body package="SUnitToo" selector="announceError:">announceError: anException 	TestCase announce: ((SomeError testCase: self) exception: anException)</body><body package="SUnitToo" selector="announceFailure:">announceFailure: anException 	TestCase announce: ((Failure testCase: self) exception: anException)</body><body package="SUnitToo" selector="announcePass">announcePass	TestCase announce: (Pass testCase: self)</body><body package="SUnitToo" selector="announceStarted">announceStarted	TestCase announce: (Started testCase: self)</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>running</category><body package="SUnitToo" selector="debug">debug	"this is for legacy support really, the debug mode in the tool is just happy to just use run, but some may have used this as a hook, so we forward that here"	^self run</body><body package="SUnitToo" selector="doTestCycle">doTestCycle		[self setUp.	self performTest] ensure: [self tearDown]</body><body package="SUnitToo" selector="handledExceptions">handledExceptions	^Error, FailedAssertion</body><body package="SUnitToo" selector="run">run	"If we use a double dispatch pattern here, we can (A) reduce the number of nested blocks (B) make it easier for people's custom exceptions to do 'interesting' things for test case occurence -- Much thanks to Andres Valloud for suggesting this."		[self announceStarted.	self doTestCycle.	self announcePass]			on: self handledExceptions			do: [:ex | ex occurredForTest: self]</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>converting</category><body package="SUnitToo" selector="asDefinition">asDefinition	^(MethodDefinition class: self class selector: testSelector) resolve</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>initialize-release</category><body package="SUnitToo" selector="setUp">setUp</body><body package="SUnitToo" selector="tearDown">tearDown</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>test case support</category><body package="SUnitToo" selector="looksLikeTestMethod:selector:">looksLikeTestMethod: aCompiledMethod selector: aMethodSelector	^(aMethodSelector copyFrom: 1 to: (4 min: aMethodSelector size)) = 'test'		or: [aCompiledMethod hasAttributeSelector: #test]</body><body package="SUnitToo" selector="looksLikeTestSelector:">looksLikeTestSelector: aMethodSelector 	^(aMethodSelector copyFrom: 1 to: (4 min: aMethodSelector size)) = 'test'</body><body package="SUnitToo" selector="testSelectorsDo:">testSelectorsDo: aBlock 	self testSelectorsDo: aBlock skipping: IdentitySet new</body><body package="SUnitToo" selector="testSelectorsDo:skipping:">testSelectorsDo: aBlock skipping: aCollection	self == TestCase ifTrue: [^self].	self selectorsAndMethodsDo: 			[:eachSelector :eachMethod |			(self looksLikeTestMethod: eachMethod selector: eachSelector)				ifTrue: 					[(aCollection includes: eachSelector)						ifFalse: 							["aBlock cull: eachSelector cull: eachMethod."							"replaced calls to &gt;&gt;cull: with that methods implementation..."							aBlock numArgs &lt; 2								ifTrue: [									aBlock numArgs = 0										ifTrue: [aBlock value]										ifFalse: [aBlock value: eachSelector]]								ifFalse: [aBlock value: eachSelector value: eachMethod].							aCollection add: eachSelector]]].	self shouldInheritSelectors		ifTrue: [superclass testSelectorsDo: aBlock skipping: aCollection]</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>accessing</category><body package="SUnitToo" selector="allTestSelectors">allTestSelectors	^self allSelectors asSortedCollection asOrderedCollection select: [:each | 'test*' match: each]</body><body package="SUnitToo" selector="resources">resources	"Subclasses may choose to return resources here."	^#()</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>announcements</category><body package="SUnitToo" selector="noResultsWhile:">noResultsWhile: aBlock 	self subscriptionRegistry allSubscriptions suspendWhile: aBlock</body><body package="SUnitToo" selector="subscriptionRegistry:">subscriptionRegistry: newRegistry 	MySubscriptions := newRegistry</body><body package="SUnitToo" selector="subscriptionRegistryOrNil">subscriptionRegistryOrNil	^MySubscriptions</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>private</category><body package="SUnitToo" selector="allResources">allResources	"Compute the union of all resources gathered either from the resources method, or from &lt;resource&gt; tagged methods. Keep them in a definitive order."	| result byMethod classToSearch visitedMethods |	result := #().	self resources do: 			[:eachResource |			result := TestResource appendResources: (Array with: eachResource)						to: result].	classToSearch := self class.	visitedMethods := Set with: #resources.	[classToSearch = TestCase class superclass] whileFalse: 			[byMethod := Pragma						allNamed: #resource						in: classToSearch						sortedUsing: [:a :b | a selector &lt; b selector].			byMethod do: 					[:eachMethodTag |					(visitedMethods includes: eachMethodTag selector)						ifFalse: 							[visitedMethods add: eachMethodTag selector.							(self perform: eachMethodTag selector)								ifNotNil: 									[:resources |									(resources isKindOf: TestResource)										ifTrue: 											[result := TestResource appendResources: (Array with: resources) to: result]										ifFalse: 											["assume it's a collection of them"											result := TestResource appendResources: resources to: result]]]].			classToSearch := classToSearch superclass].	^result</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>testing</category><body package="SUnitToo" selector="isAbstract">isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^subclasses size ~= 0</body><body package="SUnitToo" selector="isTestCase">isTestCase	^true</body><body package="SUnitToo" selector="needsComment">needsComment	"TestCases aren't usually commented"	^false</body><body package="SUnitToo" selector="shouldInheritSelectors">shouldInheritSelectors	"This deviates from classic SUnit (for now). I don't care for the 'guesses' it makes. With the SUnit one, you can have an empty class one minute which is inheriting, decide you need to add a specific test, and suddenly you quit inheriting, unless you flip this switch. That kind of coupled logic is just wrong."	^self inheritsFrom: TestCase</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>instance creation</category><body package="SUnitToo" selector="selector:">selector: aSymbol 	^self new setTestSelector: aSymbol</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbe</class-id> <category>accessing</category><body package="SequenceDiagram" selector="fileName">fileName	^self variables at: #fileName ifAbsent: ['sequenceDiagram2.txt']</body><body package="SequenceDiagram" selector="fileName:">fileName: anObject	self variables at: #fileName put: anObject</body><body package="SequenceDiagram" selector="node">node	^self variables at: #node</body><body package="SequenceDiagram" selector="node:">node: anASTNode 	self variables at: #node put: anASTNode</body><body package="SequenceDiagram" selector="otherProbe:">otherProbe: aProbe	otherProbe := aProbe</body><body package="SequenceDiagram" selector="packages">packages	^self variables at: #packages</body><body package="SequenceDiagram" selector="packages:">packages: anObject	self variables at: #packages put: anObject</body><body package="SequenceDiagram" selector="seqDiagInst">seqDiagInst	^self variables at: #seqDiagInst</body><body package="SequenceDiagram" selector="seqDiagInst:">seqDiagInst: seqDiagInst 	self variables at: #seqDiagInst put: seqDiagInst</body><body package="SequenceDiagram" selector="stream:">stream: aStream 	self variables at: #stream put: aStream</body><body package="SequenceDiagram" selector="streamFromFile">streamFromFile	^self variables at: #stream ifAbsentPut: [ self fileName asFilename newReadWriteStream]</body><body package="SequenceDiagram" selector="transformerCode">transformerCode	^self variables at: #transformerCode</body><body package="SequenceDiagram" selector="transformerCode:">transformerCode: stCode 	self variables at: #transformerCode put: stCode</body><body package="SequenceDiagram" selector="variables">variables	"SUPER CLASS IMPLEMENTATION IS NOT LAZY.... HERE IS THE GOOD ONE..."	^variables ifNil: [variables := Dictionary new]</body><body package="SequenceDiagram" selector="way">way	^self variables at: #way</body><body package="SequenceDiagram" selector="way:">way: anObject	self variables at: #way put: anObject</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbe</class-id> <category>editor creation</category><body package="SequenceDiagram" selector="createEditorOn:class:">createEditorOn: probedMethod class: probedClass	self forClass: probedClass.	^(BlockNodeProbeEditor on: self in: probedMethod class: probedClass) createEditor</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbe</class-id> <category>responses</category><body package="SequenceDiagram" selector="actOn:">actOn: aContext 	(self test: aContext) 		ifTrue: 			[self way = #in 				ifTrue: 					[self packages ifNil: [^self].					self variables removeKey: #stream ifAbsent: [].					self seqDiagInst: (SequenceDiagram.SequenceDiagram 								prepareOnPackages: self packages								writeIn: self streamFromFile								withTransformers: self transformerCode).					otherProbe copyValuesFrom: self].			self way = #out 				ifTrue: 					[otherProbe seqDiagInst postExecution.					self streamFromFile close]]</body><body package="SequenceDiagram" selector="transformerCodeExecuted">transformerCodeExecuted	self transformerCode halt</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbe</class-id> <category>copying</category><body package="SequenceDiagram" selector="copyValuesFrom:">copyValuesFrom: theOriginalProbe 	self fileName: theOriginalProbe fileName.	self packages: theOriginalProbe packages.	self stream: theOriginalProbe streamFromFile.	self seqDiagInst: theOriginalProbe seqDiagInst.	self transformerCode: theOriginalProbe transformerCode</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbe class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="onNode:">onNode: anASTNode 	^(self new)		node: anASTNode;		yourself</body><body package="SequenceDiagram" selector="onNode:way:">onNode: anASTNode way: aWay	^(self new)		node: anASTNode;		way: aWay;		yourself</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>accessing</category><body package="FameMultivalueLinksPkg" selector="add:">add: anElement	anElement perform: opposite with: owner.	self unsafeAdd: anElement.	^ anElement</body><body package="FameMultivalueLinksPkg" selector="at:">at: index	^values at: index</body><body package="FameMultivalueLinksPkg" selector="byName:">byName: name	^ self byName: name ifAbsent: [ self errorNotFound: name ]</body><body package="FameMultivalueLinksPkg" selector="byName:ifAbsent:">byName: name ifAbsent: exceptionBlock	^values			detect: [ :each | each name asString = name asString ]			ifNone: exceptionBlock</body><body package="FameMultivalueLinksPkg" selector="size">size	^values size</body><body package="FameMultivalueLinksPkg" selector="value">value	^self</body><body package="FameMultivalueLinksPkg" selector="value:">value: aCollection	^self removeAll: values copy; addAll: aCollection</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>accessing-computed</category><body package="FameMultivalueLinksPkg" selector="first">first	^ self at: 1</body><body package="FameMultivalueLinksPkg" selector="last">last	^ values last</body><body package="FameMultivalueLinksPkg" selector="second">second	^ self at: 2</body><body package="FameMultivalueLinksPkg" selector="third">third	^ self at: 3</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>comparing</category><body package="FameMultivalueLinksPkg" selector="=">= otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ values hasEqualElements: otherCollection asOrderedCollection</body><body package="FameMultivalueLinksPkg" selector="hash">hash	"Answer a uniformly distributed SmallInteger computed from the contents 	 of the receiver. This algorithm is congruent with String&gt;stringhash. I.e. 	 an Array of a sequence of characters has the same hash as a String of 	 those same characters."	| size |	^0 = (size := self size)		ifTrue: [12345]		ifFalse: 			[| midLeft midRight nextToLast firstc mlc mrc nlc lastc |			size = 1				ifTrue: [midLeft := midRight := nextToLast := 1]				ifFalse: 					[midLeft := size bitShift: -1.					midRight := midLeft + 1.					nextToLast := size - 1].			firstc := (self at: 1) hash.			mlc := (self at: midLeft) hash.			mrc := (self at: midRight) hash.			nlc := (self at: nextToLast) hash.			lastc := (self at: size) hash.			mrc			+ (mrc + size bitShift: 8)			+ ((firstc + nlc bitAnd: 16383) bitShift: 12)			+ (nlc bitShift: 2)			+ ((lastc bitAnd: 2047) bitShift: 16)			+ (firstc + lastc bitShift: 4)			+ ((mlc bitAnd: 255) bitShift: 20)			+ (mlc bitShift: 6)]</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>copying</category><body package="FameMultivalueLinksPkg" selector=",">, aCollection	^ self asOrderedCollection , aCollection</body><body package="FameMultivalueLinksPkg" selector="postCopy">postCopy	super postCopy.	values := values copy.</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>enumerating</category><body package="FameMultivalueLinksPkg" selector="do:">do: aBlock 		values do: aBlock</body><body package="FameMultivalueLinksPkg" selector="doWithIndex:">doWithIndex: aBlock 		values doWithIndex: aBlock</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>private</category><body package="FameMultivalueLinksPkg" selector="species">species	^OrderedCollection</body><body package="FameMultivalueLinksPkg" selector="unsafeAdd:">unsafeAdd: element	(values reverseIncludes: element)		ifFalse: [ values add: element ]</body><body package="FameMultivalueLinksPkg" selector="unsafeRemove:">unsafeRemove: element	values remove: element ifAbsent: nil</body><body package="FameMultivalueLinksPkg" selector="with:opposite:">with: element opposite: oppositeSelector	self assert: oppositeSelector numArgs = 1.	values := OrderedCollection new.	owner := element.	opposite := oppositeSelector</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>printing</category><body package="FameMultivalueLinksPkg" selector="printOn:">printOn: aStream	self asArray printOn: aStream</body></methods><methods><class-id>FMMultivalueLink</class-id> <category>removing</category><body package="FameMultivalueLinksPkg" selector="remove:ifAbsent:">remove: anElement ifAbsent: exceptionBlock 		values remove: anElement ifAbsent: [ ^exceptionBlock value ].	anElement perform: opposite with: nil.	^anElement</body></methods><methods><class-id>FMMultivalueLink class</class-id> <category>instance creation</category><body package="FameMultivalueLinksPkg" selector="on:opposite:">on: element opposite: oppositeSelector	^self new		with: element		opposite: oppositeSelector</body><body package="FameMultivalueLinksPkg" selector="on:update:from:to:">on: element update: selector from: old to: new	"refresh the other side of the relations to reflect change in value"		old ~= new ifTrue: [		old ifNotNil: [ (old perform: selector) unsafeRemove: element ].		new ifNotNil: [ (new perform: selector) unsafeAdd: element ]].	^new</body></methods><methods><class-id>MethodWrapper</class-id> <category>comparing</category><body package="MethodWrappersApp" selector="=">= aCompiledMethod	^self == aCompiledMethod or: [super = aCompiledMethod]</body></methods><methods><class-id>MethodWrapper</class-id> <category>private</category><body package="MethodWrappersApp" selector="arrayPosition">arrayPosition	self numArgs == 0 ifTrue: [^0].	^(1 to: self size)		detect: [:i | (self realAt: i) == #Array or: [(self realAt: i) == Array]]		ifNone: [self error: 'Cannot find position for Array']</body><body package="MethodWrappersApp" selector="at:">at: anIndex 	"Lie about what's in our literal frame. This has the bad side-effect that we 	can't view the correct information in inspectors, but the good news is that 	we stop infinite recursion. Good thing the VM doesn't use the basicAt: 	method :)."	| object |	object := super at: anIndex.	^object == self ifTrue: [clientMethod] ifFalse: [object]</body><body package="MethodWrappersApp" selector="basicAt:">basicAt: anIndex 	"Lie about what's in our literal frame. This has the bad side-effect that we 	can't view the correct information in inspectors, but the good news is that 	we stop infinite recursion. Good thing the VM doesn't use the basicAt: 	method :)."	| object |	object := super basicAt: anIndex.	^object == self ifTrue: [clientMethod] ifFalse: [object]</body><body package="MethodWrappersApp" selector="realAt:">realAt: anIndex	^super basicAt: anIndex</body><body package="MethodWrappersApp" selector="replaceLiteral:with:">replaceLiteral: literal with: anObject	self withAllBlockMethodsDo: [:meth |		1 to: meth size do: [:i || each |			each := meth realAt: i.			each == literal ifTrue: [meth at: i put: anObject]]]</body></methods><methods><class-id>MethodWrapper</class-id> <category>initialize-release</category><body package="MethodWrappersApp" selector="class:selector:">class: aClass selector: sel 	| position |	position := self arrayPosition.	position == 0 ifFalse: [self at: position put: Array].	mclass := aClass.	selector := sel</body></methods><methods><class-id>MethodWrapper</class-id> <category>accessing</category><body package="MethodWrappersApp" selector="install">install	| definingClass method |	definingClass := mclass whichClassIncludesSelector: selector.	definingClass isNil ifTrue: [self error: 'Cannot wrap an undefined method'].	method := definingClass compiledMethodAt: selector.	method == self ifTrue: [^self].	clientMethod := method.	self replaceLiteral: self class methodWrapperSymbol with: clientMethod.	mclass addSelector: selector withMethod: self</body><body package="MethodWrappersApp" selector="resourceType">resourceType	^clientMethod isNil		ifTrue: [super resourceType]		ifFalse: [clientMethod resourceType]</body><body package="MethodWrappersApp" selector="selector">selector	^selector</body><body package="MethodWrappersApp" selector="uninstall">uninstall	mclass isNil ifTrue: [^self].	(mclass compiledMethodAt: selector ifAbsent: [nil]) == self ifTrue: 			[mclass == clientMethod mclass				ifTrue: [mclass addSelector: selector withMethod: clientMethod]				ifFalse: [mclass removeSelector: selector]] </body><body package="MethodWrappersApp" selector="unwrappedMethod">unwrappedMethod	^clientMethod unwrappedMethod</body></methods><methods><class-id>MethodWrapper</class-id> <category>testing</category><body package="MethodWrappersApp" selector="referencesLiteral:">referencesLiteral: literal	"Answer whether the receiver or a contained block	 references literal. The object can either be an element	 of an array or the key or value of an association."	1 to: self numLiterals do: [:i || lit |		((lit := self basicAt: i) ~~ self			and: [lit equalsLiteral: literal])				ifTrue: [^true]].	^false</body></methods><methods><class-id>MethodWrapper</class-id> <category>source code management</category><body package="MethodWrappersApp" selector="sourceString">sourceString	^self sourcePointer</body></methods><methods><class-id>MethodWrapper</class-id> <category>evaluating</category><body package="MethodWrappersApp" selector="valueWithReceiver:arguments:">valueWithReceiver: object arguments: args 	^clientMethod valueWithReceiver: object arguments: args</body></methods><methods><class-id>MethodWrapper</class-id> <category>enumerating</category><body package="MethodWrappersApp" selector="withAllBlockMethodsDo:">withAllBlockMethodsDo: aBlock 	"Don't recurse into the literal for self, and evaluate for clientMethod so that we can find literals in 	clientMethods."	super withAllBlockMethodsDo: aBlock.	clientMethod notNil		ifTrue: [clientMethod withAllBlockMethodsDo: aBlock].</body></methods><methods><class-id>MethodWrapper class</class-id> <category>testing</category><body package="MethodWrappersApp" selector="canWrap:inClass:">canWrap: aSelector inClass: aClass 	"Test if a method can be wrapped without causing infinite recursion."	| class method |	(aClass includesBehavior: MethodWrapper) ifTrue: [^false].	aClass == BlockClosure ifTrue: 			[(#(#valueAsUnwindBlockFrom: #valueNowOrOnUnwindDo: #ensure:) includes: aSelector)				ifTrue: [^false]].	class := aClass whichClassIncludesSelector: aSelector.	class isNil ifTrue: [^false].	method := class compiledMethodAt: aSelector ifAbsent: [nil].	^method notNil and: [(self primitives includes: method primitiveNumber) not]</body></methods><methods><class-id>MethodWrapper class</class-id> <category>private</category><body package="MethodWrappersApp" selector="codeStringFor:preBody:postBody:">codeStringFor: numArgs preBody: preBodyString postBody: postBodyString	"Code in the preBodyString or postBodyString may reference the method arguments using the name 'arg' followed by the argument number.  Code in the postBodyString may reference the return value using 'reply'.  Note that in the case of a method unwind, the reply will NOT be set (therefore it will be nil).  If a different value is desired, initialize it in the preBodyString.  The preBodyString should be a complete Smalltalk statement, including being terminated with a period."	| nameString tempsString code trailer needReply |	nameString := 'value'.	trailer := postBodyString isEmpty not.	needReply := (postBodyString findString: 'reply' startingAt: 1) ~= 0.	tempsString := numArgs == 0				ifTrue: ['argArray := #()']				ifFalse: ['(argArray := #Array new: ' , numArgs printString , ') '].	1 to: numArgs		do: 			[:i | 			nameString := nameString , 'value: arg' , i printString , ' '.			tempsString := tempsString , (i == 1 ifTrue: [''] ifFalse: [';']) , ' at: '						, i printString , ' put: arg' , i printString].	code := nameString, '\	"This is a method wrapper.  DO NOT DECOMPILE!  (You have been warned...)"\' withCRs.	code := code, '\	| argArray' withCRs, (needReply ifTrue: [' reply'] ifFalse: ['']), ' |' withCRs.	preBodyString isEmpty not ifTrue: [code := code, '\	' withCRs, preBodyString].	code := code, '\	' withCRs, tempsString , '.\	^' withCRs.	trailer ifTrue: [		code := code, '['].		needReply ifTrue: [code := code, 'reply := '].	code := code, self methodWrapperSymbol printString, ' valueWithReceiver: self arguments: argArray'.	trailer ifTrue: [		code := code, ']\		valueNowOrOnUnwindDo: [' withCRs, postBodyString, ']'].	^code</body><body package="MethodWrappersApp" selector="createMethodFor:preBody:postBody:">createMethodFor: numArgs preBody: preBodyString postBody: postBodyString	"Build an instance of MethodWrapper."	^self generateFrom: (self							codeStringFor: numArgs							preBody: preBodyString							postBody: postBodyString)</body><body package="MethodWrappersApp" selector="generateFrom:">generateFrom: aString	"Answer an instance of MethodWrapper built from aString."	| wrapper |	wrapper := ((MethodWrapperCompiler new)					methodClass: self;					compile: aString						in: self						notifying: nil						ifFail: []) generate.	wrapper sourcePointer: (aString asText emphasizeAllWith: #color-&gt;ColorValue darkRed).	^wrapper</body><body package="MethodWrappersApp" selector="methodWrapperSymbol">methodWrapperSymbol	^#WrappedMethod</body><body package="MethodWrappersApp" selector="primitives">primitives	^#(61	"at:put:"	71	"new:"	523	"valueWithReceiver:arguments:"	501)	"value"</body></methods><methods><class-id>MethodWrapper class</class-id> <category>instance creation</category><body package="MethodWrappersApp" selector="on:inClass:">on: selector inClass: class	^self on: selector inClass: class preBody: ''</body><body package="MethodWrappersApp" selector="on:inClass:preBody:">on: selector inClass: class preBody: aString	^self on: selector inClass: class preBody: aString postBody: ''</body><body package="MethodWrappersApp" selector="on:inClass:preBody:postBody:">on: selector inClass: class preBody: preBodyString postBody: postBodyString	| wrapper |	(self canWrap: selector inClass: class) ifFalse: [^nil].	wrapper := self createMethodFor: selector numArgs preBody: preBodyString postBody: postBodyString.	wrapper class: class selector: selector.	^wrapper</body></methods><methods><class-id>MethodWrapper class</class-id> <category>accessing</category><body package="MethodWrappersApp" selector="uninstallAllWrappers">uninstallAllWrappers	"Emergency method to uninstall everything"	"MethodWrapper uninstallAllWrappers"	MethodWrapper withAllSubclasses		do: [:each | each allInstances do: [:inst | inst uninstall]]</body></methods><methods><class-id>MethodWrapperCompiler</class-id> <category>private</category><body package="MethodWrappersApp" selector="methodClass">methodClass	^methodClass</body><body package="MethodWrappersApp" selector="methodClass:">methodClass: aClass	methodClass := aClass</body></methods><methods><class-id>SequenceDiagram.JumpFinder</class-id> <category>accessing</category><body package="SequenceDiagram" selector="jumpId">jumpId	^jumpId</body><body package="SequenceDiagram" selector="jumpId:">jumpId: anObject	jumpId := anObject</body><body package="SequenceDiagram" selector="pcToFind">pcToFind	^pcToFind</body><body package="SequenceDiagram" selector="pcToFind:">pcToFind: anObject	pcToFind := anObject</body></methods><methods><class-id>SequenceDiagram.JumpFinder</class-id> <category>opcodes-control</category><body package="SequenceDiagram" selector="jump:">jump: delta 	| pcToJumpTo |	pcToJumpTo := pc + delta.	((loopHeads includes: pcToJumpTo) and: [ pcToJumpTo &lt; pcToFind and: [ pcToFind &lt; pc]]) 		ifTrue: 			[found := true.			jumpId := pcToJumpTo]</body><body package="SequenceDiagram" selector="loopHead">loopHead	loopHeads add: pc -1</body></methods><methods><class-id>SequenceDiagram.JumpFinder</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	found := false.	loopHeads := OrderedCollection new.	[self atEnd or: [found]] 		whileFalse: [self interpretNextInstructionFor: self]</body></methods><methods><class-id>LAN.Node</class-id> <category>sending-receiving</category><body package="LANModel" selector="accept:">accept: thePacket	"Having received the packet, send it on. This is the default behavior."	"My subclasses will probably override this method to do something special"	self send: thePacket</body><body package="LANModel" selector="send:">send: thePacket 	"Display debug information in the Transcript, then send the packet to the node which whom I 	communicate"	Transcript show: self name printString , ' sending the packet to ' , self nextNode name printString; cr.	self nextNode accept: thePacket</body></methods><methods><class-id>LAN.Node</class-id> <category>printing</category><body package="LANModel" selector="printOn:">printOn: aStream	"print a textual representation of myself on the argument, aStream"	super printOn: aStream.	aStream nextPutAll: ': ',self name asString.	self nextNode isNil ifFalse: [aStream nextPutAll: ', pointing to ',self nextNode name printString]</body></methods><methods><class-id>LAN.Node</class-id> <category>accessing</category><body package="LANModel" selector="name">name	"returns the name of the node"	^name</body><body package="LANModel" selector="name:">name: aSymbol	"sets the name of the node (a Symbol)"	name := aSymbol.	self changed: #name</body><body package="LANModel" selector="nextNode">nextNode	"return the next node of the receiver"	^nextNode</body><body package="LANModel" selector="nextNode:">nextNode: aNode	"set the next node of the receiver to be aNode"	nextNode := aNode.	self changed: #nextNode</body></methods><methods><class-id>LAN.Node</class-id> <category>moose testing</category><body package="LANModel" selector="methodWithEmptyBody">methodWithEmptyBody	"this method is necessary for Moose tests"</body></methods><methods><class-id>LAN.Node</class-id> <category>initialize-release</category><body package="LANModel" selector="initialize">initialize	"This is the default initialize method that is always called when new instances are created. My 	subclasses will likely override this method to be initialized."	"I just set my name to unnamed"	self name: #Unnamed</body></methods><methods><class-id>LAN.Node</class-id> <category>testing</category><body package="LANModel" selector="canOriginate">canOriginate	^false</body><body package="LANModel" selector="canOutput">canOutput	^false</body></methods><methods><class-id>LAN.Node class</class-id> <category>instance creation</category><body package="LANModel" selector="new">new	^super new initialize</body></methods><methods><class-id>Pharo.Object</class-id> <category>controlling</category><body package="PharoKernelAdditionsPkg" selector="ifNil:ifNotNil:">ifNil: nilBlock ifNotNil: ifNotNilBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.	 UndefinedObject redefines this to answer the evaluation of nilBlock, and hence	 since here the receiver is not nil answer the evaluation of notNilBlock."	^ ifNotNilBlock cull: self</body><body package="PharoKernelAdditionsPkg" selector="ifNotNil:">ifNotNil: aBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.  Since the receiver is not nil,	 answer aBlock's evaluation.  Passing the receiver to aBlock is handy for idioms	 such as		self toolBarSpec ifNotNil: [:spec | ...].	UndefinedObject reimplements this to not evaluate aBlock."	^aBlock cull: self</body><body package="PharoKernelAdditionsPkg" selector="ifNotNil:ifNil:">ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If the receiver is not nil, answer the evaluation of notNilBlock (with the	 receiver as its argument if it takes one), otherwise answer the evaluation	 of nilBlock.  UndefinedObject redefines this to answer the evaluation of nilBlock,	 and hence since here the receiver is not nil answer the evaluation of notNilBlock."	^ifNotNilBlock cull: self</body></methods><methods><class-id>Pharo.Object</class-id> <category>initialize-release</category><body package="PharoKernelAdditionsPkg" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."</body></methods><methods><class-id>Pharo.Object class</class-id> <category>initialize-release</category><body package="PharoKernelAdditionsPkg" selector="new">new	^ self basicNew initialize</body></methods><methods><class-id>SequenceDiagram.LoopPath</class-id> <category>accessing</category><body package="SequenceDiagram" selector="addNewLoopWithId:">addNewLoopWithId: aLoopId 	self path add: (OrderedCollection with: aLoopId with: 0).	self incrementPathIndex</body><body package="SequenceDiagram" selector="atPathEnd">atPathEnd	^self path isEmpty or: [self path size &lt; currentPathIndex]</body><body package="SequenceDiagram" selector="currentLoopId">currentLoopId	^(path at: currentPathIndex) first</body><body package="SequenceDiagram" selector="currentLoopIndex">currentLoopIndex	path ifEmpty: [^0].	^(path at: currentPathIndex) second</body><body package="SequenceDiagram" selector="currentLoopIndex:">currentLoopIndex: idx	path ifEmpty: [^self].	(path at: currentPathIndex) at: 2 put: idx</body><body package="SequenceDiagram" selector="currentPathIndex">currentPathIndex	^currentPathIndex</body><body package="SequenceDiagram" selector="currentPathIndex:">currentPathIndex: idx 	currentPathIndex := idx</body><body package="SequenceDiagram" selector="decrementPathIndex">decrementPathIndex	currentPathIndex := currentPathIndex - 1</body><body package="SequenceDiagram" selector="incrementPathIndex">incrementPathIndex	currentPathIndex := currentPathIndex + 1</body><body package="SequenceDiagram" selector="path">path	^path</body><body package="SequenceDiagram" selector="path:">path: anObject	path := anObject</body><body package="SequenceDiagram" selector="resetPathIndex">resetPathIndex	currentPathIndex := self path ifEmpty: [0] ifNotEmpty: [1]</body><body package="SequenceDiagram" selector="state">state	^self path ifNotEmpty: [#inLoop] ifEmpty: [#outOfLoop]</body></methods><methods><class-id>SequenceDiagram.LoopPath</class-id> <category>public</category><body package="SequenceDiagram" selector="addLoopId:pc:">addLoopId: aLoopId pc: aPc 	self path add: (OrderedCollection with: aLoopId with: aPc).	self incrementPathIndex</body><body package="SequenceDiagram" selector="incrementCurrentLoopIndex">incrementCurrentLoopIndex	| couple |	couple := path at: currentPathIndex.	couple at: 2 put: (couple second ifNil:[0]) + 1.</body><body package="SequenceDiagram" selector="removeLastLoop">removeLastLoop	self path: self path allButLast.	self decrementPathIndex</body></methods><methods><class-id>SequenceDiagram.LoopPath</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream &lt;&lt; ' idx '.	aStream &lt;&lt; currentPathIndex asString.	aStream &lt;&lt; ' [ '.	path printOn: aStream.	aStream &lt;&lt; '] '</body></methods><methods><class-id>SequenceDiagram.LoopPath</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	path := OrderedCollection new.	currentPathIndex := 0</body></methods><methods><class-id>SequenceDiagram.ActivationCasesPossibilities</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activationsPossibilities">activationsPossibilities	^activationsPossibilities</body><body package="SequenceDiagram" selector="activationsPossibilities:">activationsPossibilities: anObject	activationsPossibilities := anObject</body><body package="SequenceDiagram" selector="switch">switch	^switch</body><body package="SequenceDiagram" selector="switch:">switch: anObject	switch := anObject</body></methods><methods><class-id>SequenceDiagram.ActivationCasesPossibilities</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anAnotherObject 	self activationsPossibilities withIndexCollect: 			[:act :idx | 			act = anAnotherObject 				ifTrue: 					[self switch preferedIdx: idx.					^true]].	^false</body><body package="SequenceDiagram" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	^aMessage sendTo: self switch currentCase</body><body package="SequenceDiagram" selector="equalsExceptPcId:">equalsExceptPcId: anAnotherObject 	self activationsPossibilities withIndexCollect: 			[:act :idx | 			(act equalsExceptPcId: anAnotherObject )				ifTrue: 					[self switch preferedIdx: idx.					^true]].	^false</body></methods><methods><class-id>SequenceDiagram.ActivationCasesPossibilities</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	activationsPossibilities := OrderedCollection new</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputerTest</class-id> <category>test</category><body package="SequenceDiagramTest" selector="testFameMultivaluePkgDepth1NoExclusionsShouldReturnNothing">testFameMultivaluePkgDepth1NoExclusionsShouldReturnNothing	| initialPkg packages |	initialPkg := #('FameMultivalueLinksPkg'). 	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg) 				prereqNames.	self assertCollection: packages hasSameElements: initialPkg</body><body package="SequenceDiagramTest" selector="testFameMultivaluePkgDepth2NoExclusionsShouldReturnNothing">testFameMultivaluePkgDepth2NoExclusionsShouldReturnNothing	| initialPkg packages |	initialPkg := #('FameMultivalueLinksPkg'). 	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg depth: 2) 				prereqNames.	self assertCollection: packages  hasSameElements: initialPkg</body><body package="SequenceDiagramTest" selector="testMethodWrappersAppDepth1NoExclusionsShouldReturn">testMethodWrappersAppDepth1NoExclusionsShouldReturn	| expectedPrerequisites initialPkg packages |	initialPkg := #('MethodWrappersApp').	expectedPrerequisites := #('EnvyKernel'), initialPkg.	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg) 				prereqNames.	self deny: packages isEmpty.	self assert: packages size equals: expectedPrerequisites size.	self assertCollection: packages hasSameElements: expectedPrerequisites</body><body package="SequenceDiagramTest" selector="testMethodWrappersAppDepth2NoExclusionsShouldReturn">testMethodWrappersAppDepth2NoExclusionsShouldReturn	| expectedPrerequisites initialPkg packages |	initialPkg := #('MethodWrappersApp').	expectedPrerequisites := #('EnvyKernel').	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg depth: 2) 				prereqNames.	self deny: packages isEmpty.	self assert: packages size equals: expectedPrerequisites size +1.	self assertCollection: packages hasSameElements: expectedPrerequisites, initialPkg</body><body package="SequenceDiagramTest" selector="testSequenceDiagDepth1NoExclusionsShouldReturn">testSequenceDiagDepth1NoExclusionsShouldReturn	| expectedPrerequisites initialPkg packages |	initialPkg := #('SequenceDiagram').	expectedPrerequisites := #('Debugger-Probes' 'Browser-BrowserUI' 'PharoKernelAdditionsPkg' 'LED-UI' 'LED-Rules' 'FameMultivalueLinksPkg' 'MethodWrappersApp' 'RProfiler-Utils'), initialPkg.	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg) 				prereqNames.	self deny: packages isEmpty.	self assert: packages size equals: expectedPrerequisites size.	self assertCollection: packages hasSameElements: expectedPrerequisites</body><body package="SequenceDiagramTest" selector="testSequenceDiagDepth2NoExclusionsShouldReturnALotMoreOfPkgs">testSequenceDiagDepth2NoExclusionsShouldReturnALotMoreOfPkgs	| expectedPrerequisites initialPkg packages |	initialPkg := #('SequenceDiagram').	expectedPrerequisites := #('Debugger-Probes' 'Browser-BrowserUI' 'PharoKernelAdditionsPkg' 'LED-UI' 'LED-Rules' 'FameMultivalueLinksPkg' 'MethodWrappersApp' 'RProfiler-Utils'), initialPkg.	packages := (PackagePrerequisitesComputer initialPackageNames: initialPkg depth: 2) 				prereqNames.	self deny: packages isEmpty.	self assert: packages size equals: expectedPrerequisites size.	self assertCollection: packages hasSameElements: expectedPrerequisites</body></methods><methods><class-id>SUnit.TestResourceError</class-id> <category>accessing</category><body package="SUnitToo" selector="failingResource">failingResource	^failingResource</body><body package="SUnitToo" selector="failingResource:">failingResource: anObject	failingResource := anObject</body><body package="SUnitToo" selector="originalException">originalException	^originalException</body><body package="SUnitToo" selector="originalException:">originalException: anObject	originalException := anObject</body><body package="SUnitToo" selector="parameter">parameter	"backwards compatibility"	^self resourceSet</body><body package="SUnitToo" selector="resourceSet">resourceSet	^resourceSet</body><body package="SUnitToo" selector="resourceSet:">resourceSet: anObject	resourceSet := anObject</body></methods><methods><class-id>SUnit.TestResourceError</class-id> <category>initialize-release</category><body package="SUnitToo" selector="parameter:">parameter: aResourceSet	"backwards compatibility"	^self resourceSet: aResourceSet</body></methods><methods><class-id>SUnit.TestResourceError class</class-id> <category>testing</category><body package="SUnitToo" selector="mayResume">mayResume	^true</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTest</class-id> <category>tests</category><body package="SequenceDiagramTest" selector="testSimpleModelCreation">testSimpleModelCreation	"A&gt;&gt;bar invoke A&gt;&gt;foo"	| pkg class method instOfA activation |	pkg := Package named: #dummy.	class := pkg newClass: #A.	method := class newMethod: #foo.	instOfA := class newInstance.	activation := instOfA activate: method on: instOfA direction: #in.	self assert: class package equals: pkg.	self assert: method clazz equals: class.	self assert: instOfA clazz equals: class.	self assert: activation receiver equals: instOfA.	"self assertCollection: instOfA activationReceived equals: (OrderedCollection with: activation)."	self assert: activation creator equals: instOfA.	"self assertCollection: method activationCreated equals: (OrderedCollection with: activation)."	self assert: activation method equals: method.	"self assertCollection: method activation equals: (OrderedCollection with: activation)."	</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramTest</class-id> <category>running</category><body package="SequenceDiagramTest" selector="setUp">setUp	super setUp.	instance := SequenceDiagramCreator new</body><body package="SequenceDiagramTest" selector="tearDown">tearDown	instance ifNotNil: 			[:i | 			instance instrumentedMethods 				do: [:col | [(col first compiledMethodAt: col second) uninstall. col third uninstall] on: Error do: [:niark |] ]]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramTest</class-id> <category>tests</category><body package="SequenceDiagramTest" selector="testInstrumentLanModel">testInstrumentLanModel	instance		packages: #('LANModel');		instrumentCode.	self assert: instance instrumentedMethods size equals: 57.</body><body package="SequenceDiagramTest" selector="testNewNodeCallInstrumentation">testNewNodeCallInstrumentation	| result |	result := (instance run: [LAN.LANInterface new newNode]				onPackages: #('LANModel')) modelHolder.	(Store.Registry packageNamed: 'LANModel') methods 		do: [:c | self deny: (c isKindOf: MethodWrapper)].	self assert: (result isKindOf: SequenceDiagramModelHolder).	self assert: result numberOfInstances equals: 4.	self assert: result numberOfActivations equals: 16.	self assert: result numberOfMethods equals: 6</body><body package="SequenceDiagramTest" selector="testNewNodeCallPlantUMLGeneration">testNewNodeCallPlantUMLGeneration	| result |	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [LAN.LANInterface new newNode]						on: #('LANModel')						writeIn: stream].	self assert: result numberOfLines equals: 18.	self assert: (result numberOfOccurencesOf: '&gt;') equals: 8.	self assert: (result numberOfOccurencesOf: '&lt;') equals: 8.	self assert: (result numberOfOccurencesOf: 'nodeList') equals: 6</body><body package="SequenceDiagramTest" selector="testNewNodeCallPlantUMLGenerationWithMethodRemovalTrransformer">testNewNodeCallPlantUMLGenerationWithMethodRemovalTrransformer	| result listOfTransformers |	listOfTransformers := SequenceDiagramModelTransformerFilter 				onMethods: #(#nodeList).	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [LAN.LANInterface new newNode]						on: #('LANModel')						writeIn: stream						withTransformers: (OrderedCollection with: listOfTransformers)].	self assert: result numberOfLines equals: 12.	self assert: (result numberOfOccurencesOf: '&gt;') equals: 5.	self assert: (result numberOfOccurencesOf: '&lt;') equals: 5.	self assert: (result numberOfOccurencesOf: 'nodeList') equals: 0</body><body package="SequenceDiagramTest" selector="testOneInvocationInstrumentationGraphGeneration">testOneInvocationInstrumentationGraphGeneration	| result string |	result := instance run: [LAN.Packet new contents] onPackages: #('LANModel').	(Store.Registry packageNamed: 'LANModel') methods 		do: [:c | self deny: (c isKindOf: MethodWrapper)].	self assert: (result modelHolder isKindOf: SequenceDiagramModelHolder).	string := String 				streamContents: [:aStream | SequenceDiagramWriter runOn: aStream with: result modelHolder].	self assert: string isNotEmpty.	self assert: string numberOfLines equals: 4.	self assert: (string beginsWith: '@startumlLAN.Packet').	self assert: (string endsWith: ': contents@enduml')</body><body package="SequenceDiagramTest" selector="testOneInvocationInstrumentationModelGeneration">testOneInvocationInstrumentationModelGeneration	| result acts insts clazz meths |	result := (instance run: [LAN.Packet new contents]				onPackages: #('LANModel')) modelHolder.	(Store.Registry packageNamed: 'LANModel') methods 		do: [:c | self deny: (c isKindOf: MethodWrapper)].	self assert: (result isKindOf: SequenceDiagramModelHolder).	acts := result activations.	self assert: acts size equals: 2.	insts := result instances.	self assert: insts size equals: 1.	clazz := result classes.	self assert: clazz size equals: 1.	meths := result methods.	self assert: meths size equals: 1.	self assert: acts first method equals: meths first.	self assert: acts first creator equals: insts first.	self assert: acts first receiver equals: insts first</body><body package="SequenceDiagramTest" selector="testThatOnlyOneClassShouldBeCreatedForAllTheInstancesOfLANNode">testThatOnlyOneClassShouldBeCreatedForAllTheInstancesOfLANNode	| lan result |	lan := LAN.LANInterface new.	1 to: 100 do: [:e | lan newNode].	result := (instance run: [lan changedNode] onPackages: #('LANModel')) modelHolder.	self assert: result classes size equals: 2.	self assert: result instances size equals: 101.	self assert: result methods size equals: 4.	self assert: (result clazzNamed: 'LAN.Node') instances size equals: 100.	self 		assert: ((result clazzNamed: 'LAN.Node') instances 				flatCollect: #activationsCreated) size		equals: 200.	self 		assert: ((result clazzNamed: 'LAN.Node') instances 				flatCollect: #activationsReceived) size		equals: 200</body><body package="SequenceDiagramTest" selector="testUniqueInstance">testUniqueInstance	| lan result listOfTransformers |	lan := LAN.LANInterface new.	1 to: 100 do: [:e | lan newNode].	listOfTransformers := SequenceDiagramModelTransformerUniqueInstance new.	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [lan changedNode]						on: #('LANModel')						writeIn: stream						withTransformers: (OrderedCollection with: listOfTransformers)].	self assert: result numberOfLines equals: 208.	self assert: (result numberOfOccurencesOf: '&gt;') equals: 103.	self assert: (result numberOfOccurencesOf: '&lt;') equals: 103.	self assert: (result numberOfOccurencesOf: 'nodeList') equals: 2</body><body package="SequenceDiagramTest" selector="testUniqueInstanceTransformer">testUniqueInstanceTransformer	| lan result transformer |	lan := LAN.LANInterface new.	1 to: 100 do: [:e | lan newNode].	result := (instance run: [lan changedNode] onPackages: #('LANModel')) modelHolder.	transformer := SequenceDiagramModelTransformerUniqueInstance new.	transformer runOn: result.	self assert: result classes size equals: 2.	self assert: result instances size equals: 2.	self assert: result methods size equals: 4.	self assert: (result clazzNamed: 'LAN.Node') instances size equals: 1.	self 		assert: ((result clazzNamed: 'LAN.Node') instances 				flatCollect: #activationsCreated) size		equals: 200.	self 		assert: ((result clazzNamed: 'LAN.Node') instances 				flatCollect: #activationsReceived) size		equals: 200.	self assert: result activations size equals: 206.</body><body package="SequenceDiagramTest" selector="testUniqueInstanceTransformerAndGeneration">testUniqueInstanceTransformerAndGeneration	| lan result listOfTransformers |	lan := LAN.LANInterface new.	1 to: 100 do: [:e | lan newNode].	listOfTransformers := SequenceDiagramModelTransformerUniqueInstance new.	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [lan changedNode]						on: #('LANModel')						writeIn: stream						withTransformers: (OrderedCollection with: listOfTransformers)].	self assert: result numberOfLines equals: 208.	self assert: (result numberOfOccurencesOf: 'LAN.Node -') equals: 100.	self assert: (result numberOfOccurencesOf: '&gt; LAN.Node: name') equals: 100.	self assert: (result numberOfOccurencesOf: 'LAN.Node &lt;') equals: 100.	self assert: (result numberOfOccurencesOf: '-- LAN.Node: name') equals: 100</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramTest</class-id> <category>tests-loop</category><body package="SequenceDiagramTest" selector="testIndirectCallThroughLoop">testIndirectCallThroughLoop	| cA transformer modelHolder |	cA := ClassA new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator 				run: [1 to: 10 do: [:e | cA methodOrigin]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: modelHolder activations first activations size equals: 4</body><body package="SequenceDiagramTest" selector="testLoopCondensation">testLoopCondensation	| lan result listOfTransformers |	lan := LAN.LANInterface new.	1 to: 100 do: [:e | lan newNode].	listOfTransformers := OrderedCollection 				with: SequenceDiagramModelTransformerUniqueInstance new				with: SequenceDiagramModelTransformerLoopCondenser new.	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [lan changedNode]						on: #('LANModel')						writeIn: stream						withTransformers: listOfTransformers].	self assert: result numberOfLines equals: 12.	self assert: (result numberOfOccurencesOf: 'LAN.Node -')		equals: 1.	self assert: (result numberOfOccurencesOf: '&gt; LAN.Node: name')		equals: 1.	self assert: (result numberOfOccurencesOf: 'loop') equals: 1.	self assert: (result numberOfOccurencesOf: 'end') equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationMessageLoopWith2MessagesThenMessage">testLoopCondensationMessageLoopWith2MessagesThenMessage	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[lan := LAN.LANInterface new.					1 to: 30						do: 							[:e | 							lan newNode.							lan newNode].					lan changedNode]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 14.	self assert: ((modelHolder activations at: 7) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 7) activations size equals: 20.	self assert: ((modelHolder activations at: 11) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 11) activations size equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationShouldSeparateInnerLoopThenMessageCall">testLoopCondensationShouldSeparateInnerLoopThenMessageCall	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator  run: [1 to: 2 do: [:e | lan newNode. ]. lan changedNode ]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.		self assert: (modelHolder activations first isKindOf: ActivationLoop).	self assert: modelHolder activations first activations size equals: 10.	self assert: modelHolder activations size equals: 8 "loop + last call".</body><body package="SequenceDiagramTest" selector="testLoopCondensationSimpleDouble">testLoopCondensationSimpleDouble	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[1 to: 100						do: 							[:e | 							lan newNode.							lan newNode]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: (modelHolder activations first isKindOf: ActivationLoop).	self assert: modelHolder activations first activations size equals: 20</body><body package="SequenceDiagramTest" selector="testLoopCondensationVeryShort">testLoopCondensationVeryShort	| lan modelHolder transformer |	lan := LAN.LANInterface new.	1 to: 3 do: [:e | lan newNode].	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: [lan changedNode]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 7.	self assert: (modelHolder activations fourth isKindOf: ActivationLoop).	self assert: modelHolder activations fourth activations size equals: 2.	self assert: modelHolder activations fourth counter equals: 3</body><body package="SequenceDiagramTest" selector="testLoopCondensationVeryShortWithWriting">testLoopCondensationVeryShortWithWriting	| lan listOfTransformers result |	listOfTransformers := OrderedCollection 				with: SequenceDiagramModelTransformerUniqueInstance new				with: SequenceDiagramModelTransformerLoopCondenser new.	lan := LAN.LANInterface new.	1 to: 3 do: [:e | lan newNode].	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: [lan changedNode]						on: #('LANModel')						writeIn: stream						withTransformers: listOfTransformers].	self assert: result numberOfLines equals: 12.	self assert: (result numberOfOccurencesOf: '&gt; LAN.Node: name') equals: 1.	self assert: (result numberOfOccurencesOf: 'LAN.Node -') equals: 1.	self assert: (result numberOfOccurencesOf: 'loop') equals: 1.	self assert: (result numberOfOccurencesOf: 'loop 3 times') equals: 1.	self assert: (result numberOfOccurencesOf: 'end') equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationVerySimpleDouble">testLoopCondensationVerySimpleDouble	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[1 to: 3						do: 							[:e | 							lan newNode.							lan newNode]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: (modelHolder activations first isKindOf: ActivationLoop).	self assert: modelHolder activations first activations size equals: 20.</body><body package="SequenceDiagramTest" selector="testLoopCondensationVerySimpleDoubleLoopWithAnotherCallInsideThe2Loops">testLoopCondensationVerySimpleDoubleLoopWithAnotherCallInsideThe2Loops	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[1 to: 3						do: 							[:e | 							lan newNode.							lan cancel.							lan newNode]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: (modelHolder activations first isKindOf: ActivationLoop).	self assert: modelHolder activations first activations size equals: 22</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternative">testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternative	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[lan := LAN.LANInterface new.					1 to: 4						do: 							[:e | 							lan contents.							e odd ifTrue: [lan newNode] ifFalse: [lan cancel]]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 7.	self assert: ((modelHolder activations at: 7) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 7) activations size equals: 3.	switch := (modelHolder activations at: 7) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 2.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 10.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternativeAndWriteIt">testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternativeAndWriteIt	| lan listOfTransformers result |	lan := LAN.LANInterface new.	listOfTransformers := OrderedCollection 				with: SequenceDiagramModelTransformerUniqueInstance new				with: SequenceDiagramModelTransformerLoopCondenser new.	result := String streamContents: 					[:stream | 					SequenceDiagram 						run: 							[lan := LAN.LANInterface new.							1 to: 4								do: 									[:e | 									lan contents.									e odd ifTrue: [lan newNode] ifFalse: [lan cancel]]]						on: #('LANModel')						writeIn: stream						withTransformers: listOfTransformers].	self assert: result numberOfLines equals: 27.	self assert: (result numberOfOccurencesOf: 'LAN.Node -') equals: 1.	self assert: (result numberOfOccurencesOf: '&gt; LAN.Node: name') equals: 1.	self assert: (result numberOfOccurencesOf: 'loop') equals: 1.	self assert: (result numberOfOccurencesOf: 'alt') equals: 1.	self assert: (result numberOfOccurencesOf: 'else') equals: 1.	self assert: (result numberOfOccurencesOf: 'end') equals: 3</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternativeWithoutNoise">testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnAlternativeWithoutNoise	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[1 to: 4						do: 							[:e | 							lan contents.							e odd ifTrue: [lan newNode] ifFalse: [lan cancel]]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: ((modelHolder activations at: 1) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 1) activations size equals: 3.	self assert: (modelHolder activations at: 1) counter equals: 4.	switch := (modelHolder activations at: 1) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 2.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 10.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnInvertedAlternative">testLoopCondensationWithAlternativeAndAFirstMessageAtRootShouldCreateAnInvertedAlternative	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[					1 to: 4						do: 							[:e | 							lan contents.							e odd ifTrue: [lan cancel] ifFalse: [lan newNode]]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: ((modelHolder activations at: 1) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 1) activations size equals: 3.	switch := (modelHolder activations at: 1) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 2.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 2.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 10</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeIndependentTripleCase">testLoopCondensationWithAlternativeIndependentTripleCase	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[1 to: 7						do: 							[:e | 							lan contents.							e odd 								ifTrue: [e \\ 3 = 0 ifTrue: [lan accept] ifFalse: [lan newNode]]								ifFalse: [lan cancel]]]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: ((modelHolder activations at: 1) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 1) activations size equals: 3.	self assert: (modelHolder activations at: 1) counter equals: 7.	switch := (modelHolder activations at: 1) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 3.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 10.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 2.	self assert: (switch cases third isKindOf: ActivationCase).	self assert: switch cases third activations size equals: 2</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithDoubleLoopAndCallsBeforeAndAfter">testLoopCondensationWithDoubleLoopAndCallsBeforeAndAfter	| lan modelHolder transformer sw |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := (SequenceDiagramCreator run: 					[lan := LAN.LANInterface new.					1 to: 10						do: 							[:e | 							lan newNode.							e odd ifTrue: [lan newNode] ifFalse: [lan cancel]].					lan changedNode]				onPackages: #('LANModel')) modelHolder.	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 14.	self assert: ((modelHolder activations at: 7) isKindOf: ActivationLoop).	self assert: ((modelHolder activations at: 7) activations 				count: [:i | i isKindOf: ActivationSwitch])		equals: 1.	sw := (modelHolder activations at: 7) activations at: 11.	self assert: (sw isKindOf: ActivationSwitch).	self assert: sw cases size equals: 2.	self assert: sw cases first activations size equals: 10.	self assert: sw cases second activations size equals: 2</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramTest</class-id> <category>tests-expected failure</category><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeAtRootShouldCreateAnAlternative">testLoopCondensationWithAlternativeAtRootShouldCreateAnAlternative	| lan modelHolder transformer |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := SequenceDiagramCreator run: 					[lan := LAN.LANInterface new.					1 to: 10 do: [:e | e odd ifTrue: [lan newNode] ifFalse: [lan cancel]]]				onPackages: #('LANModel').	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: true		description: 'expected failure. With the current execution model, it is not possible to know that newNode and cancel are executed in two different locations.'</body><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeTripleCase">testLoopCondensationWithAlternativeTripleCase	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := SequenceDiagramCreator run: 					[1 to: 7						do: 							[:e | 							lan contents.							e odd 								ifTrue: 									[lan newNode.									e \\ 3 = 0 ifTrue: [lan accept]]								ifFalse: [lan cancel]]]				onPackages: #('LANModel').	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: ((modelHolder activations at: 1) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 1) activations size equals: 3.	self assert: (modelHolder activations at: 1) counter equals: 7.	switch := (modelHolder activations at: 1) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 2.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 10.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 4.	"That should be 3 different alternatives but still the same issue than the other test: not enough information to conclude..."</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramTest</class-id> <category>As yet unclassified</category><body package="SequenceDiagramTest" selector="testLoopCondensationWithAlternativeTripleDistinctsCase">testLoopCondensationWithAlternativeTripleDistinctsCase	| lan modelHolder transformer switch |	lan := LAN.LANInterface new.	transformer := SequenceDiagramModelTransformerLoopCondenser new.	modelHolder := SequenceDiagramCreator run: 					[1 to: 7						do: 							[:e | 							lan contents.							e odd ifTrue: [ e \\ 3 = 0 ifTrue: [lan accept] ifFalse: [lan newNode]] ifFalse: [lan cancel]]]				onPackages: #('LANModel').	SequenceDiagramModelTransformerUniqueInstance new runOn: modelHolder.	transformer runOn: modelHolder.	self assert: modelHolder activations size equals: 1.	self assert: ((modelHolder activations at: 1) isKindOf: ActivationLoop).	self assert: (modelHolder activations at: 1) activations size equals: 3.	self assert: (modelHolder activations at: 1) counter equals: 7.	switch := (modelHolder activations at: 1) activations third.	self assert: (switch isKindOf: ActivationSwitch).	self assert: switch cases size equals: 3.	self assert: (switch cases first isKindOf: ActivationCase).	self assert: switch cases first activations size equals: 10.	self assert: (switch cases second isKindOf: ActivationCase).	self assert: switch cases second activations size equals: 2</body></methods><methods><class-id>SequenceDiagram.Instance</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activationsCreated">activationsCreated	^activationsCreated</body><body package="SequenceDiagram" selector="activationsCreated:">activationsCreated: anObject	activationsCreated value: anObject</body><body package="SequenceDiagram" selector="activationsReceived">activationsReceived	^activationsReceived</body><body package="SequenceDiagram" selector="activationsReceived:">activationsReceived: anObject	activationsReceived value: anObject</body><body package="SequenceDiagram" selector="clazz">clazz	^clazz</body><body package="SequenceDiagram" selector="clazz:">clazz: anObject	clazz := FMMultivalueLink 		on: self		update: #instances		from: self clazz		to: anObject</body><body package="SequenceDiagram" selector="instanceId">instanceId	^instanceId</body><body package="SequenceDiagram" selector="instanceId:">instanceId: anId 	instanceId := anId</body><body package="SequenceDiagram" selector="name">name	^self clazz name , (self instanceId ifNil: ['']) asString</body></methods><methods><class-id>SequenceDiagram.Instance</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	self clazz printOn: aStream.	aStream &lt;&lt; '-'.	 self instanceId printOn: aStream.</body></methods><methods><class-id>SequenceDiagram.Instance</class-id> <category>removing</category><body package="SequenceDiagram" selector="remove">remove	self clazz: nil.	self activationsCreated removeAll.	self activationsReceived removeAll</body></methods><methods><class-id>SequenceDiagram.Instance</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="activate:on:direction:">activate: aMethod on: aReceiver direction: aDirection	^Activation 		newCreator: self		call: aMethod		to: aReceiver		direction: aDirection</body><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	instanceId := self class incrementIdCounter.	activationsCreated := FMMultivalueLink on: self opposite: #creator:.	activationsReceived := FMMultivalueLink on: self opposite: #receiver:</body></methods><methods><class-id>SequenceDiagram.Instance</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anObject 	^self class = anObject class 		and: [self instanceId = anObject instanceId and: [self clazz = anObject clazz]]</body><body package="SequenceDiagram" selector="hash">hash	^self instanceId hash bitXor: self clazz hash</body></methods><methods><class-id>SequenceDiagram.Instance class</class-id> <category>private</category><body package="SequenceDiagram" selector="incrementIdCounter">incrementIdCounter	InstanceIdCounter := InstanceIdCounter + 1.	^InstanceIdCounter</body></methods><methods><class-id>SequenceDiagram.Instance class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="from:">from: aClass 	^(self new)		clazz: aClass;		yourself</body></methods><methods><class-id>SequenceDiagram.ActivationSwitch</class-id> <category>testing</category><body package="SequenceDiagram" selector="isAlternateCase">isAlternateCase	^true</body><body package="SequenceDiagram" selector="isLoopEnd">isLoopEnd	^self currentCase isLoopEnd</body></methods><methods><class-id>SequenceDiagram.ActivationSwitch</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="add:">add: anActivation 	^(self cases at: currentCaseIdx) add: anActivation</body><body package="SequenceDiagram" selector="addAllInFirstCase:">addAllInFirstCase: aCollectionOfActivations 	^self cases first addAll: aCollectionOfActivations</body><body package="SequenceDiagram" selector="addInCurrentCase:">addInCurrentCase: anActivation 	self currentCase add: anActivation</body><body package="SequenceDiagram" selector="addInFirstCase:">addInFirstCase: anActivation 	^self cases first add: anActivation</body><body package="SequenceDiagram" selector="addNewCase">addNewCase	| newCase |	newCase := (ActivationCase				new)				switch: self;				yourself.	self cases add: newCase.	currentCaseIdx := self cases size.	^newCase</body><body package="SequenceDiagram" selector="atIndex:">atIndex: anIndex 	| possibleCases currentIdx val |	currentIdx := anIndex value.	possibleCases := (self cases collect: 					[:case | 					val := #key -&gt; currentIdx.					case atIndex: val]) 				select: #notNil.	anIndex value: val value.	possibleCases ifEmpty: [^nil].	possibleCases size = 1 ifTrue: [^possibleCases first].	^(ActivationCasesPossibilities new)		switch: self;		activationsPossibilities: possibleCases;		yourself</body><body package="SequenceDiagram" selector="atIndex:ifAbsent:">atIndex: anIndex ifAbsent: anAbsentBlock 	| possibleCases |	self halt.	possibleCases:= self cases collect: [:case | case atIndex: anIndex ifAbsent: anAbsentBlock ].	ActivationCasesPossibilities new.	self halt.</body><body package="SequenceDiagram" selector="direction">direction  	^ self currentCase first direction</body><body package="SequenceDiagram" selector="findIndexOfItemSuchThat:">findIndexOfItemSuchThat: aBlock 	"Maybe we should prefer a case compared to another one..."	(aBlock value: self) ifTrue: [^1].	^(self currentCase findIndexOfItemSuchThat: aBlock) ifNil: 			[self cases do: 					[:case | 					| idx |					idx := case findIndexOfItemSuchThat: aBlock.					idx ifNotNil: [^idx]].			nil]</body><body package="SequenceDiagram" selector="numberOfItems">numberOfItems	^self currentCase numberOfItems</body><body package="SequenceDiagram" selector="pcId">pcId	^self currentCase first pcId</body><body package="SequenceDiagram" selector="switch">switch	^self</body><body package="SequenceDiagram" selector="writeDiagramOn:">writeDiagramOn: aDiagramWriter	aDiagramWriter writeSwitch: self</body></methods><methods><class-id>SequenceDiagram.ActivationSwitch</class-id> <category>accessing</category><body package="SequenceDiagram" selector="cases">cases	^cases</body><body package="SequenceDiagram" selector="cases:">cases: anObject	cases := anObject</body><body package="SequenceDiagram" selector="currentCase">currentCase	self preferedIdx ifNotNil: [^self cases at: self preferedIdx].	^self cases at: currentCaseIdx</body><body package="SequenceDiagram" selector="preferedIdx">preferedIdx	^preferedIdx</body><body package="SequenceDiagram" selector="preferedIdx:">preferedIdx: anObject	preferedIdx := anObject</body></methods><methods><class-id>SequenceDiagram.ActivationSwitch</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream &lt;&lt; '[ '.	self cases do: [:c | c printOn: aStream ] separatedBy: [ aStream &lt;&lt; ','].	aStream &lt;&lt; '] '.</body></methods><methods><class-id>SequenceDiagram.ActivationSwitch</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	cases := OrderedCollection new.</body></methods><methods><class-id>SUnit.FailedAssertion</class-id> <category>sunit</category><body package="SUnitToo" selector="occurredForTest:">occurredForTest: aTestCase 	"double dispatch back to the test"	aTestCase announceFailure: self.	self return</body></methods><methods><class-id>SequenceDiagram.ClassA</class-id> <category>public</category><body package="SequenceDiagramTestResources" selector="initialize">initialize 	super initialize.	bool := true.	lan := LAN.LANInterface new.</body><body package="SequenceDiagramTestResources" selector="methodFalse">methodFalse	^false</body><body package="SequenceDiagramTestResources" selector="methodOrigin">methodOrigin	bool 		ifTrue: 			[bool := false.			lan accept]		ifFalse: 			[bool := true.			lan cancel]</body><body package="SequenceDiagramTestResources" selector="methodTrue">methodTrue	^ true	</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbeEditor</class-id> <category>interface opening</category><body package="SequenceDiagram" selector="createEditor">createEditor	^self createEditorOn: #logEditorSpec</body><body package="SequenceDiagram" selector="hookUpWindowParametersTo:">hookUpWindowParametersTo: aBuilder"	| sourceHolder levelHolder |	sourceHolder := ValueHolder with: workingCopyProbe source.	aBuilder aspectAt: #source put: sourceHolder.	sourceHolder		onChangeSend: #value		to: [workingCopyProbe source: sourceHolder value].	levelHolder := ValueHolder with: workingCopyProbe level.	aBuilder aspectAt: #level put: levelHolder.	levelHolder		onChangeSend: #value		to: [workingCopyProbe level: levelHolder value]."</body><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	self availablePackages list: Store.Registry allPackages asList sorted.	self availablePackages selectionIndexes: OrderedCollection new.	self selectedPackages selectionIndexes: 0.	packageAvailability := Array new: self availablePackages list size				withAll: true.	Store.Registry addDependent: self</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbeEditor</class-id> <category>accessing</category><body package="SequenceDiagram" selector="addToSelectedPackages">addToSelectedPackages	| selectionIndexes |	selectionIndexes := self availablePackages selectionIndexes.	selectionIndexes = 0 ifTrue: [^self].	selectionIndexes do: 			[:i | 			self selectedPackages list add: (self availablePackages list at: i).			self packageAtIndex: i isAvailable: false].	self availablePackages selectionIndexes: OrderedCollection new</body><body package="SequenceDiagram" selector="availablePackages">availablePackages	^availablePackages ifNil: [^availablePackages := MultiSelectionInList new]</body><body package="SequenceDiagram" selector="fileName">fileName	^fileName ifNil: [^fileName := 'sequenceDiagram.txt']</body><body package="SequenceDiagram" selector="packageAtIndex:isAvailable:">packageAtIndex: anIndex isAvailable: aBool 	packageAvailability at: anIndex put: aBool</body><body package="SequenceDiagram" selector="selectedPackages">selectedPackages	^selectedPackages ifNil: [^selectedPackages := MultiSelectionInList new]</body><body package="SequenceDiagram" selector="selectedPackages:">selectedPackages: anObject	selectedPackages := anObject</body><body package="SequenceDiagram" selector="transformerCode">transformerCode	^transformerCode ifNil: [^transformerCode := 'OrderedCollection new' asValue]</body><body package="SequenceDiagram" selector="transformerCode:">transformerCode: anObject	transformerCode := anObject</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbeEditor</class-id> <category>testing</category><body package="SequenceDiagram" selector="isPackageAvailableAtIndex:">isPackageAvailableAtIndex: anIndex 	^packageAvailability at: anIndex</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbeEditor</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="accept">accept	workingCopyProbe packages: (self selectedPackages list collect: #name).	workingCopyProbe fileName: self fileName.	workingCopyProbe transformerCode: (self class evaluatorClass 				evaluate: self transformerCode value).	super accept</body><body package="SequenceDiagram" selector="disturb">disturb	disturbed := true</body><body package="SequenceDiagram" selector="okSelection:">okSelection: aSequenceController		^self isPackageAvailableAtIndex: aSequenceController view targetIndex</body><body package="SequenceDiagram" selector="removeFromSelectedPackages">removeFromSelectedPackages	self selectedPackages selection ifNotNil: 			[:package | 			| availablePkg |			availablePkg := self availablePackages list indexOf: package.			self packageAtIndex: availablePkg isAvailable: true.			(self builder componentAt: #availablePackageView) widget 				updateAt: availablePkg.			self selectedPackages selection: nil.			self selectedPackages list remove: package]</body></methods><methods><class-id>LAN.OutputServer</class-id> <category>outputting</category><body package="LANModel" selector="output:">output: thePacket	"My subclasses have to use this method to define their outputting behavior"	self subclassResponsibility</body></methods><methods><class-id>LAN.OutputServer</class-id> <category>testing</category><body package="LANModel" selector="canOutput">canOutput	^true</body></methods><methods><class-id>LAN.OutputServer</class-id> <category>sending-receiving</category><body package="LANModel" selector="accept:">accept: thePacket 	"I first see if the packet is for me. If it is, I output it. Otherwise, I pass it on"	(thePacket addressee isDestinationFor: self name) 	"self name = thePacket addressee"		ifTrue: [self output: thePacket]		ifFalse: [self send: thePacket]</body></methods><methods><class-id>LAN.FileServer</class-id> <category>setting</category><body package="LANModel" selector="setServerType">setServerType	serverType := 'FileServer'</body></methods><methods><class-id>LAN.FileServer</class-id> <category>outputting</category><body package="LANModel" selector="name">name	"added for candidate invocations operator test"		^super name</body><body package="LANModel" selector="output:">output: thePacket 	"My subclasses have to use this method to define their outputting behavior"	Transcript cr.	Transcript show: 'FileServer ' , self name printString , ' saves ' , thePacket contents</body></methods><methods><class-id>LAN.PrintServer</class-id> <category>outputting</category><body package="LANModel" selector="output:">output: thePacket 	"My subclasses have to use this method to define their outputting behavior"	Transcript cr.	80 timesRepeat: [Transcript show: '-'].	Transcript cr.	Transcript show: 'Printer ' , self name printString , ' prints ' , thePacket contents</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	instrumentedMethods := OrderedCollection new</body><body package="SequenceDiagram" selector="run:onPackages:">run: aBlock onPackages: aCollectionOfPackages 	self generateInstanceId.	self packages: aCollectionOfPackages.		[self instrumentCode.	self execute: aBlock] 			ensure: [self uninstrumentMethods].</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator</class-id> <category>accessing</category><body package="SequenceDiagram" selector="blockExecutionResult">blockExecutionResult	^blockExecutionResult</body><body package="SequenceDiagram" selector="instanceId">instanceId	^instanceId</body><body package="SequenceDiagram" selector="instrumentedMethods">instrumentedMethods	^instrumentedMethods</body><body package="SequenceDiagram" selector="modelHolder">modelHolder	^modelHolder</body><body package="SequenceDiagram" selector="modelHolder:">modelHolder: anObject	modelHolder := anObject</body><body package="SequenceDiagram" selector="packages">packages	^packages</body><body package="SequenceDiagram" selector="packages:">packages: aCollectionOfPackages 	packages := aCollectionOfPackages</body><body package="SequenceDiagram" selector="postBodyAction:">postBodyAction: aContext 	| act loopData |	self modelHolder ifNotNil: 			[:mh | 			act := mh 						addNewActivationFromContext: aContext						direction: #out						process: Process current identityHash.			loopData := self extractLoopIdFrom: aContext sender sender sender.			loopData ifNotNil: 					[act loopId: loopData first.					act pcId: loopData second]]</body><body package="SequenceDiagram" selector="postBodyString">postBodyString	^String streamContents: 			[:s | 			s &lt;&lt; '('.			s &lt;&lt; self class fullName.			s &lt;&lt; ' instance: '.			self instanceId printOn: s.			s &lt;&lt; ') postBodyAction: thisContext.']</body><body package="SequenceDiagram" selector="preBodyAction:">preBodyAction: aContext 	| act loopData |	self modelHolder ifNotNil: 			[:mh | 			act := mh 						addNewActivationFromContext: aContext						direction: #in						process: Process current identityHash.			loopData := self extractLoopIdFrom: aContext.			loopData ifNotNil: 					[act loopId: loopData first.					act pcId: loopData second]]</body><body package="SequenceDiagram" selector="preBodyString">preBodyString	^String streamContents: 			[:s | 			s &lt;&lt; '('.			s &lt;&lt; self class fullName.			s &lt;&lt; ' instance: '.			self instanceId printOn: s.			s &lt;&lt; ') preBodyAction: thisContext.']</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator</class-id> <category>private</category><body package="SequenceDiagram" selector="execute:">execute: aBlock	self modelHolder: SequenceDiagramModelHolder new.	blockExecutionResult := aBlock value.	self modelHolder clean</body><body package="SequenceDiagram" selector="generateInstanceId">generateInstanceId	instanceId := (Random new next * 100000) asInteger.	self class instancesDict at: instanceId put: self</body><body package="SequenceDiagram" selector="instrumentCode">instrumentCode	| methodsToInstrument mw |	methodsToInstrument := self packages 				flatCollect: [:pkgName | (Store.Registry packageNamed: pkgName) methods].	instrumentedMethods := methodsToInstrument collect: 					[:m | 					mw := MethodWrapper 								on: m selector								inClass: m classFromClassName								preBody: self preBodyString								postBody: self postBodyString.					(OrderedCollection new)						add: m classFromClassName;						add: m selector;						add: mw;						yourself].	instrumentedMethods do: [:col | col third install].</body><body package="SequenceDiagram" selector="uninstrumentMethods">uninstrumentMethods	instrumentedMethods do: 			[:col | 						[(col first compiledMethodAt: col second) uninstall.			col third uninstall] 					on: Error					do: [:niark |]]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator</class-id> <category>public-unsafe</category><body package="SequenceDiagram" selector="postExecution">postExecution	self uninstrumentMethods.	self modelHolder clean.	^modelHolder</body><body package="SequenceDiagram" selector="prepareOnPackages:">prepareOnPackages: aCollectionOfPackages 	"The post process HAVE TO be executed once this method has been called"	self generateInstanceId.	self packages: aCollectionOfPackages.	self instrumentCode.	self modelHolder: SequenceDiagramModelHolder new</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="extractLoopIdFrom:">extractLoopIdFrom: aContext 	"Get an identifier for the first loop encountered in the stack. Use identityHash (can be duplicates...)"	"10 is really arbitrary to explore the stack and find the loop. It may be changed to sth else."	| sender jumpId recursivePc |	sender := aContext.	"sender selector  =  #changedNode ifTrue: [self halt]."	recursivePc := 0.	[true] whileTrue:			[ 			sender := sender sender.			sender ifNil: [^nil].			(sender method homeMethod isKindOf: MethodWrapper) ifTrue: [^nil].						recursivePc := recursivePc + sender pc.			((InstructionStream on: sender method) scanFor: [:e | e = 103	"loop head"]) 				ifTrue: 					[jumpId := (JumpFinder on: sender method)						pcToFind: sender pc;						run; jumpId.						jumpId ifNil: ["the messge is not in the loop"^nil]. 					^OrderedCollection with: sender identityHash + jumpId with: recursivePc]].	^nil</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator class</class-id> <category>accessing</category><body package="SequenceDiagram" selector="instance:">instance: anInstance	^InstancesDict at: anInstance</body><body package="SequenceDiagram" selector="instancesDict">instancesDict	^InstancesDict</body><body package="SequenceDiagram" selector="reset">reset	self initialize</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	InstancesDict := Dictionary new</body><body package="SequenceDiagram" selector="run:onPackages:">run: aBlock onPackages: aCollectionOfPackages	^self new		run:  aBlock onPackages: aCollectionOfPackages</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramCreator class</class-id> <category>public-unsafe</category><body package="SequenceDiagram" selector="prepareOnPackages:">prepareOnPackages: aCollectionOfPackages 	^(self new)		prepareOnPackages: aCollectionOfPackages;		yourself</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramWriter</class-id> <category>accessing</category><body package="SequenceDiagram" selector="model">model	^model</body><body package="SequenceDiagram" selector="model:">model: anObject	model := anObject</body><body package="SequenceDiagram" selector="stream">stream	^stream</body><body package="SequenceDiagram" selector="stream:">stream: anObject	stream := anObject</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramWriter</class-id> <category>running</category><body package="SequenceDiagram" selector="run">run	self writeStart.	self writeActivations.	self writeEnd</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramWriter</class-id> <category>private</category><body package="SequenceDiagram" selector="writeActivations">writeActivations	model activations do: [:activation | activation writeDiagramOn: self]</body><body package="SequenceDiagram" selector="writeEnd">writeEnd	stream &lt;&lt; '@enduml'</body><body package="SequenceDiagram" selector="writeStart">writeStart	stream &lt;&lt; '@startuml'; cr</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramWriter</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="colorFromProcess:">colorFromProcess: anNumber 	| colors |	colors := #('ff0000' 'ff4000' 'ff8000' 'ffbf00' 'ffff00' 'bfff00' '80ff00' '40ff00' '00ff00' '00ff40' '00ff80' '00ffbf' '00ffff' '00bfff' '0080ff' '0040ff' '0000ff' '8000ff' 'bf00ff' 'ff00ff' 'ff00bf' 'ff0080' 'ff0040').	^colors at: (anNumber \\ colors size) +1</body><body package="SequenceDiagram" selector="uniformizeName:">uniformizeName: aString 	^aString replaceChar: Core.Character space withChar: $_</body><body package="SequenceDiagram" selector="writeActivation:">writeActivation: anActivation 	stream &lt;&lt; (self uniformizeName: anActivation creator name).	stream &lt;&lt; (anActivation direction = #in 				ifTrue: [' -[#' , (self colorFromProcess: anActivation process) , ']&gt; ']				ifFalse: [' &lt;[#' , (self colorFromProcess: anActivation process) , ']-- ']).	stream &lt;&lt; (self uniformizeName: anActivation receiver name).	stream &lt;&lt; ': '.	stream &lt;&lt; (self uniformizeName: anActivation method name).	stream cr</body><body package="SequenceDiagram" selector="writeActivationLoop:">writeActivationLoop: anActivationLoop	stream &lt;&lt; ' loop ' &lt;&lt; anActivationLoop counter asString &lt;&lt; ' times' ;cr.	anActivationLoop activations do: [ :act | act writeDiagramOn: self ].	stream &lt;&lt; ' end' ;cr.</body><body package="SequenceDiagram" selector="writeSwitch:">writeSwitch: anActivationSwitch 	stream		&lt;&lt; 'alt';		cr.	anActivationSwitch cases 		do: [:case | case activations do: [:act | act writeDiagramOn: self]]		separatedBy: 			[stream				&lt;&lt; 'else';				cr].	stream		&lt;&lt; 'end';		cr</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramWriter class</class-id> <category>instance creation</category><body package="SequenceDiagram" selector="on:with:">on: aStream with: aSDModelHolder 	^(self new)		stream: aStream;		model: aSDModelHolder;		yourself</body><body package="SequenceDiagram" selector="runOn:with:">runOn: aStream with: aSDModelHolder 	^(self on: aStream with: aSDModelHolder) run</body></methods><methods><class-id>FMMultiMultivalueLink</class-id> <category>adding</category><body package="FameMultivalueLinksPkg" selector="add:">add: anElement	(anElement perform: opposite) unsafeAdd: owner.	(values reverseIncludes: anElement) not ifTrue: [		values add: anElement ].	^anElement</body></methods><methods><class-id>FMMultiMultivalueLink</class-id> <category>removing</category><body package="FameMultivalueLinksPkg" selector="remove:ifAbsent:">remove: anElement ifAbsent: exceptionBlock 		values remove: anElement ifAbsent: [ ^exceptionBlock value ].	(anElement perform: opposite) unsafeRemove: owner.	^anElement</body></methods><methods><class-id>FMMultiMultivalueLink</class-id> <category>private</category><body package="FameMultivalueLinksPkg" selector="with:opposite:">with: element opposite: oppositeSelector	self assert: oppositeSelector numArgs = 0.	values := OrderedCollection new.	owner := element.	opposite := oppositeSelector</body></methods><methods><class-id>SequenceDiagram.ActivationCase</class-id> <category>testing</category><body package="SequenceDiagram" selector="isAlternateCase">isAlternateCase	^true</body><body package="SequenceDiagram" selector="isLoopEnd">isLoopEnd	^self activations last isLoopEnd</body></methods><methods><class-id>SequenceDiagram.ActivationCase</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activations">activations	^activations</body><body package="SequenceDiagram" selector="activations:">activations: anObject	activations := anObject</body><body package="SequenceDiagram" selector="add:">add: anActivation	self activations add: anActivation</body><body package="SequenceDiagram" selector="addAll:">addAll: anActivation	self activations addAll: anActivation</body><body package="SequenceDiagram" selector="atIndex:">atIndex: anIndex 	| res |	self activations do: 			[:item | 			res := item atIndex: anIndex.			res ifNotNil: [^res]].	^nil</body><body package="SequenceDiagram" selector="atIndex:ifAbsent:">atIndex: anIndex ifAbsent: anAbsentBlock 	self halt.</body><body package="SequenceDiagram" selector="findIndexOfItemSuchThat:">findIndexOfItemSuchThat: aBlock 	| res idx |	res := 0.	self activations do: 			[:item | 			idx := item findIndexOfItemSuchThat: aBlock.			idx ifNil: [res := res + item numberOfItems] ifNotNil: [^res + idx]].	^nil</body><body package="SequenceDiagram" selector="first">first	^self activations first</body><body package="SequenceDiagram" selector="switch">switch	^switch</body><body package="SequenceDiagram" selector="switch:">switch: anObject	switch := anObject</body></methods><methods><class-id>SequenceDiagram.ActivationCase</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream &lt;&lt; '[ '.	self activations do: [:c | c printOn: aStream ] separatedBy: [ aStream &lt;&lt; ','].	aStream &lt;&lt; '] '.</body></methods><methods><class-id>SequenceDiagram.ActivationCase</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	activations := OrderedCollection new.</body></methods><methods><class-id>SequenceDiagram.ActivationCase</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="addAllInFirstCase:">addAllInFirstCase: anActivation	self switch addAllInFirstCase: anActivation</body><body package="SequenceDiagram" selector="addInCurrentCase:">addInCurrentCase: anActivation	self add: anActivation</body><body package="SequenceDiagram" selector="addInFirstCase:">addInFirstCase: anActivation	self switch addInFirstCase: anActivation</body><body package="SequenceDiagram" selector="numberOfItems">numberOfItems	^ self activations sum: [ :act | act numberOfItems ]</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputer</class-id> <category>accessing</category><body package="SequenceDiagram" selector="depth">depth	^depth</body><body package="SequenceDiagram" selector="depth:">depth: anObject	depth := anObject</body><body package="SequenceDiagram" selector="excludes">excludes	^excludesPkg</body><body package="SequenceDiagram" selector="excludes:">excludes: aColOfPkg	excludesPkg := aColOfPkg</body><body package="SequenceDiagram" selector="excludesNames:">excludesNames: anObject	excludesNames := anObject 				collect: [:pkgName | Store.Registry packageNamed: pkgName]</body><body package="SequenceDiagram" selector="initialPackageNames:">initialPackageNames: aCollectionOfPkgNames 	initialPackages := aCollectionOfPkgNames 				collect: [:pkgName | Store.Registry packageNamed: pkgName]</body><body package="SequenceDiagram" selector="initialPackages">initialPackages	^initialPackages</body><body package="SequenceDiagram" selector="initialPackages:">initialPackages: aCollectionOfPackages 	initialPackages := aCollectionOfPackages</body><body package="SequenceDiagram" selector="prereqNames">prereqNames	^prereqs collect: #name</body><body package="SequenceDiagram" selector="prereqs">prereqs	^prereqs</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputer</class-id> <category>private</category><body package="SequenceDiagram" selector="addEnvironmentPrereqsFrom:">addEnvironmentPrereqsFrom: t1 	| t3 |	t3 := 			[:t4 | 			| t5 |			(t5 := t1 detect: [:t6 | t6 definesClassOrNameSpace: t4 environment]						ifNone: [nil]) notNil 				ifTrue: 					[prereqs add: t5.					t1 remove: t5]				ifFalse: [nil]].	(self codeComponentEnvironment)		classesDo: t3;		nameSpacesDo: t3.	^self</body><body package="SequenceDiagram" selector="addReferencePrereqsFrom:">addReferencePrereqsFrom: allItems	self referencedBindings do: 			[:each | 			| codeComponent |			codeComponent := allItems detect: 							[:codeCmp | 							each isForGeneral 								ifTrue: [									(Root whoDefinesBinding: each)										ifNil: [false]										ifNotNil: [:def | codeCmp definesName: each key in: def]]								ifFalse: [codeCmp definesClassOrNameSpace: each value]]						ifNone: [nil].			codeComponent notNil 				ifTrue: 					[prereqs add: codeComponent.					allItems remove: codeComponent]]</body><body package="SequenceDiagram" selector="allCodeComponents">allCodeComponents	| allPackages |	allPackages := OrderedCollection withAll: self storeRegistry allPackages.	(self storeRegistry bundleNamed: 'Base VisualWorks') allContainedItems 		do: [:pkg | allPackages remove: pkg ifAbsent: [nil]].	^allPackages</body><body package="SequenceDiagram" selector="codeComponentEnvironment">codeComponentEnvironment	^Refactory.Browser.PundleEnvironment 		onEnvironment: Refactory.Browser.BrowserEnvironment new		pundles: self initialPackages</body><body package="SequenceDiagram" selector="prerequisitesFor:">prerequisitesFor: t1 	| t2 |	t2 := Set new.	self prerequisitesFor: t1 into: t2.	^t2</body><body package="SequenceDiagram" selector="prerequisitesFor:into:">prerequisitesFor: t1 into: t2 	| t3 t4 |	t4 := self storeRegistry.	t3 := 			[:t5 | 			t5 notNil 				ifTrue: 					[(t2 includes: t5) 						ifTrue: [nil]						ifFalse: 							[t2 add: t5.							self prerequisitesFor: t5 into: t2]]				ifFalse: [nil]].	t1 deploymentPrerequisites do: 			[:t6 | 			t3 value: (Parcel parcelNamed: t6 first).			t4 notNil 				ifTrue: 					[t3 value: (t4 packageNamed: t6 first).					t3 value: (t4 bundleNamed: t6 first)]				ifFalse: [nil]].	^self</body><body package="SequenceDiagram" selector="referencedBindings">referencedBindings	| env bindings |	bindings := IdentitySet new.	(env := self codeComponentEnvironment) classesDo: [:clazz | (env definesClass: clazz)			ifTrue: [clazz superclass notNil					ifTrue: [bindings add: (clazz superclass environment bindingFor: clazz superclass name)]					ifFalse: [nil]]			ifFalse: [bindings add: (clazz environment bindingFor: clazz name)]].	env methodsDo: [:t4 | t4			allLiteralsDo: 				[:t5 | 				t5 isVariableBinding ifTrue: [bindings add: t5 nonDeferredBinding].				t5 isBindingReference					ifTrue: [bindings add: t5 bindingOrNil]					ifFalse: [nil]]].	^bindings</body><body package="SequenceDiagram" selector="removeDuplicatePrereqs">removeDuplicatePrereqs	prereqs copy 		do: [:t2 | (self prerequisitesFor: t2) do: [:t4 | prereqs remove: t4 ifAbsent: [nil]]].	^self</body><body package="SequenceDiagram" selector="storeRegistry">storeRegistry	^#{Store.Registry} valueOrDo: [nil]</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputer</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	prereqs := OrderedCollection new</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputer</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	| allPackages |	allPackages := self allCodeComponents.	allPackages removeAll: self initialPackages ifAbsent: [].	self addReferencePrereqsFrom: allPackages.	self addEnvironmentPrereqsFrom: allPackages.	self removeDuplicatePrereqs.	(self depth &gt;= 2 and: [self prereqs isNotEmpty]) 		ifTrue: 			[prereqs := self prereqs flatCollect: 							[:pkg | 							(self class 								initialPackages: (OrderedCollection with: pkg)								depth: self depth - 1								excludes: self excludes) prereqs].			self removeDuplicatePrereqs].	prereqs addAll: self initialPackages</body></methods><methods><class-id>SequenceDiagram.PackagePrerequisitesComputer class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialPackageNames:">initialPackageNames: aCollectionOfPackageNames	^self initialPackageNames: aCollectionOfPackageNames depth: 1 excludesNames: #()</body><body package="SequenceDiagram" selector="initialPackageNames:depth:">initialPackageNames: aCollectionOfPackageNames depth: anInt	^self initialPackageNames: aCollectionOfPackageNames depth: anInt  excludesNames: #()</body><body package="SequenceDiagram" selector="initialPackageNames:depth:excludesNames:">initialPackageNames: aCollectionOfPackageNames depth: anInt excludesNames: aCollectionOfExclusions	^self new		initialPackageNames: aCollectionOfPackageNames;		depth: anInt;		excludesNames: aCollectionOfExclusions;		run</body><body package="SequenceDiagram" selector="initialPackages:depth:excludes:">initialPackages: aCollectionOfPackageNames depth: anInt excludes: aCollectionOfExclusions	^self new		initialPackages: aCollectionOfPackageNames;		depth: anInt;		excludes: aCollectionOfExclusions;		run</body></methods><methods><class-id>LAN.LANInterface</class-id> <category>actions</category><body package="LANModel" selector="accept">accept	"This stub method was generated by UIDefiner"	^self</body><body package="LANModel" selector="cancel">cancel	"This stub method was generated by UIDefiner"	^self</body><body package="LANModel" selector="changedNode">changedNode	| newMenu |	newMenu := MenuBuilder new.	self nodeList list do: [:node | newMenu add: node name-&gt;node].	self deviceNameMenu setValue: newMenu menu</body><body package="LANModel" selector="newFileServer">newFileServer	^self nodeList list add: FileServer new</body><body package="LANModel" selector="newNode">newNode	^self nodeList list add: Node new</body><body package="LANModel" selector="newPrintServer">newPrintServer	^self nodeList list add: PrintServer new</body><body package="LANModel" selector="newWorkstation">newWorkstation	^self nodeList list add: WorkStation new</body><body package="LANModel" selector="originate">originate	| dialogModel dialogBuilder returnVal packet dialogOriginator dialogAddressee dialogContents |	"the next three lines create ValueHolders to support the three dialog widgets"	dialogOriginator := nil asValue.	dialogAddressee := nil asValue.	dialogContents := String new asValue.	"next two lines create a new SimpleDialog object and retrieves the builder"	dialogModel := SimpleDialog new.	dialogBuilder := dialogModel builder.	"the following lines connect  the widgets of the interface with the ValueHolders created"	dialogBuilder aspectAt: #originator put: dialogOriginator.	dialogBuilder aspectAt: #addressee put: dialogAddressee.	dialogBuilder aspectAt: #contents put: dialogContents.	"the following lines ask the LANInterface for the originators and outputters menus. 	You will write these next, so select proceed when VisualWorks when VisualWorks indicates that they are new messages."	dialogBuilder aspectAt: #originators put: self originatorsMenu.	dialogBuilder aspectAt: #addressees put: self addresseesMenu.	"the following line actually opens the dialog interface, originateDialog, and accepts user input"	returnVal := dialogModel openFor: self interface: #originateDialog.	"returnvalue will be true if the user selected Accept, otherwise it will be false"	returnVal ifTrue: [		"create a new packet, fill it in and give it to the workstation"		packet := Packet new addressee: (SingleDestinationAddress new id: dialogAddressee value name); contents: dialogContents value. 		dialogOriginator value originate: packet]</body><body package="LANModel" selector="remove">remove	| sel |	(sel := self nodeList selection) isNil		ifFalse: [self nodeList list remove: sel].	self changedNode</body></methods><methods><class-id>LAN.LANInterface</class-id> <category>private</category><body package="LANModel" selector="addresseesMenu">addresseesMenu	| menuBuilder |	menuBuilder := MenuBuilder new.	self nodeList list do: [:each | each canOutput ifTrue: [menuBuilder add: each name -&gt; each]].	^menuBuilder menu</body><body package="LANModel" selector="originatorsMenu">originatorsMenu	| menuBuilder |	menuBuilder := MenuBuilder new.	self nodeList list do: [:each | each canOriginate ifTrue: [menuBuilder add: each name -&gt; each]].	^menuBuilder menu</body></methods><methods><class-id>LAN.LANInterface</class-id> <category>aspects</category><body package="LANModel" selector="addressee">addressee	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^addressee isNil		ifTrue:			[addressee := nil asValue]		ifFalse:			[addressee]</body><body package="LANModel" selector="contents">contents	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^contents isNil		ifTrue:			[contents := String new asValue]		ifFalse:			[contents]</body><body package="LANModel" selector="deviceNameMenu">deviceNameMenu	^deviceNameMenu isNil 		ifTrue: [deviceNameMenu := Menu new asValue]		ifFalse: [deviceNameMenu]</body><body package="LANModel" selector="nextNode">nextNode	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nextNode isNil		ifTrue:			[nextNode := nil asValue]		ifFalse:			[nextNode]</body><body package="LANModel" selector="nodeList">nodeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodeList isNil		ifTrue:			[nodeList := SelectionInList new]		ifFalse:			[nodeList]</body><body package="LANModel" selector="nodeName">nodeName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodeName isNil		ifTrue:			[nodeName := nil asValue]		ifFalse:			[nodeName]</body><body package="LANModel" selector="originator">originator	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^originator isNil		ifTrue:			[originator := nil asValue]		ifFalse:			[originator]</body></methods><methods><class-id>LAN.LANInterface</class-id> <category>initialize-release</category><body package="LANModel" selector="initialize">initialize	| selectionHolder |	super initialize.	self nodeList list: DependentList new.	selectionHolder := self nodeList selectionHolder.	nodeName := (AspectAdaptor forAspect: #name)		subjectChannel: selectionHolder.	nextNode := (AspectAdaptor forAspect: #nextNode)		subjectChannel: selectionHolder;		subjectSendsUpdates: true.</body></methods><methods><class-id>SequenceDiagram.Activation</class-id> <category>accessing</category><body package="SequenceDiagram" selector="creator">creator	^creator</body><body package="SequenceDiagram" selector="creator:">creator: anInstanceCreator	creator := FMMultivalueLink 		on: self		update: #activationsCreated		from: self creator		to: anInstanceCreator</body><body package="SequenceDiagram" selector="direction">direction	^direction</body><body package="SequenceDiagram" selector="direction:">direction: anObject	direction := anObject</body><body package="SequenceDiagram" selector="engendredActivation">engendredActivation	^engendredActivation</body><body package="SequenceDiagram" selector="engendredActivation:">engendredActivation: anObject	engendredActivation := anObject</body><body package="SequenceDiagram" selector="method">method	^method</body><body package="SequenceDiagram" selector="method:">method: aMethod	method := FMMultivalueLink 		on: self		update: #activations		from: self method		to: aMethod</body><body package="SequenceDiagram" selector="numberOfItems">numberOfItems	^1</body><body package="SequenceDiagram" selector="pcId">pcId	^pcId</body><body package="SequenceDiagram" selector="pcId:">pcId: anObject	pcId := anObject</body><body package="SequenceDiagram" selector="process">process	^process</body><body package="SequenceDiagram" selector="process:">process: anObject	process := anObject</body><body package="SequenceDiagram" selector="receiver">receiver	^receiver</body><body package="SequenceDiagram" selector="receiver:">receiver: anObject	receiver :=  FMMultivalueLink 		on: self		update: #activationsReceived		from: self receiver		to: anObject</body><body package="SequenceDiagram" selector="senderActivation">senderActivation	^senderActivation</body><body package="SequenceDiagram" selector="senderActivation:">senderActivation: anObject	senderActivation := anObject</body></methods><methods><class-id>SequenceDiagram.Activation</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream &lt;&lt; ' ('.	self method ifNotNil: [:m | m name printOn: aStream].	aStream &lt;&lt; ' '.	self creator ifNotNil: [:c | c printOn: aStream].	aStream &lt;&lt; ' -&gt; '.	self receiver ifNotNil: [:c | c printOn: aStream].	aStream &lt;&lt; ' '.	self direction ifNotNil: [:c | c printOn: aStream].	aStream &lt;&lt; ' '.	self loopId ifNotNil: [:c | c printOn: aStream].	aStream &lt;&lt; ' '.	self pcId ifNotNil: [:c | c printOn: aStream].	aStream &lt;&lt; ')'</body></methods><methods><class-id>SequenceDiagram.Activation</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="atIndex:">atIndex: anIndex 	^anIndex value = 1 		ifTrue: [self]		ifFalse: 			[anIndex value: anIndex value - self numberOfItems.			nil]</body><body package="SequenceDiagram" selector="atIndex:ifAbsent:">atIndex: anIndex ifAbsent: anAbsentBlock 	^anIndex = 1 		ifTrue: [self]		ifFalse: 			[anAbsentBlock value.			nil]</body><body package="SequenceDiagram" selector="equalsExceptPcId:">equalsExceptPcId: anObject 	^self class == anObject class and: 			[self method = anObject method and: 					[self creator = anObject creator and: 							[self receiver = anObject receiver 								and: [self direction = anObject direction]]]]</body><body package="SequenceDiagram" selector="findIndexOfItemSuchThat:">findIndexOfItemSuchThat: aBlock 	^(aBlock value: self) ifTrue: [1] ifFalse: [nil]</body><body package="SequenceDiagram" selector="isInLoop">isInLoop	"Dummy method template.  This was installed by the debugger	define method command."	^self halt</body><body package="SequenceDiagram" selector="isLoopEnd">isLoopEnd	^self direction = #out and: [self isLoop]</body><body package="SequenceDiagram" selector="loopId">loopId	^loopId</body><body package="SequenceDiagram" selector="loopId:">loopId: anInt	loopId := anInt</body><body package="SequenceDiagram" selector="remove">remove	self creator: nil.	self receiver: nil.	self method: nil.	</body><body package="SequenceDiagram" selector="writeDiagramOn:">writeDiagramOn: aDiagramWriter 	aDiagramWriter writeActivation: self</body></methods><methods><class-id>SequenceDiagram.Activation</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anObject 	^self class == anObject class and: 			[self method = anObject method and: 					[self creator = anObject creator and: 							[self receiver = anObject receiver 								and: [self direction = anObject direction and: [self pcId = anObject pcId]]]]]	"self loopId = anObject loopId : not added, because it doesnt differenciate an activation. The pc does because it means that it is another method call. The loopId just means that is belonging to another loop but it can be the same call."</body><body package="SequenceDiagram" selector="hash">hash	^(((self method hash bitXor: self creator hash) bitXor: self receiver hash) 		bitXor: self direction hash) bitXor: self pcId hash</body></methods><methods><class-id>SequenceDiagram.Activation</class-id> <category>testing</category><body package="SequenceDiagram" selector="isAlternateCase">isAlternateCase	^false</body><body package="SequenceDiagram" selector="isLoop">isLoop	^loopId notNil</body><body package="SequenceDiagram" selector="isLoopBegin">isLoopBegin	^self direction = #in and: [self isLoop]</body></methods><methods><class-id>SequenceDiagram.Activation class</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="newCreator:call:to:direction:">newCreator: anInstanceCreator call: aMethod to: anInstanceReceiver direction: aDirection 	^(self new)		creator: anInstanceCreator;		receiver: anInstanceReceiver;		method: aMethod;		direction: aDirection;		yourself</body></methods><methods><class-id>SequenceDiagram.ActivationLoop</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activationIndexOfLastPc">activationIndexOfLastPc	^self 		findIndexOfItemSuchThat: [:e | e pcId = self lastPc and: [e direction = #out]]</body><body package="SequenceDiagram" selector="activations">activations	^activations</body><body package="SequenceDiagram" selector="activations:">activations: anObject	activations := anObject</body><body package="SequenceDiagram" selector="add:">add: anActivation 	self activations add: anActivation</body><body package="SequenceDiagram" selector="atIndex:">atIndex: anIndex	|  res |	self activations do: 			[:item | 			res := item atIndex: anIndex.			res ifNotNil: [^res]].	^nil</body><body package="SequenceDiagram" selector="atIndex:ifAbsent:">atIndex: anIndex ifAbsent: anAbsentBlock 	| idx res |	idx := #key -&gt; anIndex.	self activations ifEmpty: anAbsentBlock.	self activations do: 			[:item | 			res := item atIndex: idx.			res ifNotNil: [^res]].	anAbsentBlock value</body><body package="SequenceDiagram" selector="counter">counter	^counter</body><body package="SequenceDiagram" selector="findIndexOfItemSuchThat:">findIndexOfItemSuchThat: aBlock 	| res idx |	res := 0.	self activations do: 			[:item | 			idx := item findIndexOfItemSuchThat: aBlock.			idx ifNil: [res := res + item numberOfItems] ifNotNil: [^res + idx]].	^nil</body><body package="SequenceDiagram" selector="indexOf:">indexOf: aLoopItem	^ self activations indexOf: aLoopItem</body><body package="SequenceDiagram" selector="isFull">isFull	^isFull</body><body package="SequenceDiagram" selector="isFull:">isFull: anObject	isFull := anObject</body><body package="SequenceDiagram" selector="lastPc">lastPc	^lastPc</body><body package="SequenceDiagram" selector="lastPc:">lastPc: anInt	lastPc := anInt</body><body package="SequenceDiagram" selector="numberOfItems">numberOfItems	^ self activations sum: [ :act | act numberOfItems ]</body><body package="SequenceDiagram" selector="previousItem:">previousItem: aLoopItem 	| idxOfPreviousItem |	idxOfPreviousItem := (self findIndexOfItemSuchThat: [:e |  aLoopItem == e ]) 				ifNil: [^nil].	idxOfPreviousItem &lt;= 1 ifTrue: [^nil].	^self atIndex: idxOfPreviousItem - 1 ifAbsent: []</body><body package="SequenceDiagram" selector="remove:">remove: anItem 	| col idx |	col := self activations.	idx := col identityIndexOf: anItem.	idx isZero ifFalse: [col removeIndex: idx]</body><body package="SequenceDiagram" selector="replace:with:">replace: anLoopItem with: anAnotherItem 	"I am not convinced of the replaceAll..."	^self activations replaceAll: anLoopItem with: anAnotherItem</body></methods><methods><class-id>SequenceDiagram.ActivationLoop</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	aStream &lt;&lt; 'Loop ('.	activations printOn: aStream.	aStream &lt;&lt; ')'</body></methods><methods><class-id>SequenceDiagram.ActivationLoop</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	activations := OrderedCollection new.	isFull := false.	counter := 0</body></methods><methods><class-id>SequenceDiagram.ActivationLoop</class-id> <category>actions</category><body package="SequenceDiagram" selector="incrementCounter">incrementCounter	counter := counter + 1</body></methods><methods><class-id>SequenceDiagram.ActivationLoop</class-id> <category>writing</category><body package="SequenceDiagram" selector="writeDiagramOn:">writeDiagramOn: aDiagramWriter 	aDiagramWriter writeActivationLoop: self</body></methods><methods><class-id>LAN.AbstractDestinationAddress</class-id> <category>comparing</category><body package="LANModel" selector="isDestinationFor:">isDestinationFor: aNodeAddress	^self subclassResponsibility</body></methods><methods><class-id>LAN.SingleDestinationAddress</class-id> <category>comparing</category><body package="LANModel" selector="equalsMultiple:">equalsMultiple: aSingleNodeAddress	^self halt</body><body package="LANModel" selector="equalsSingle:">equalsSingle: aSingleNodeAddress	^self id = aSingleNodeAddress id</body><body package="LANModel" selector="isDestinationFor:">isDestinationFor: aNodeAddress	^aNodeAddress equalsSingle: self</body></methods><methods><class-id>LAN.SingleDestinationAddress</class-id> <category>accessing</category><body package="LANModel" selector="id">id	^id</body><body package="LANModel" selector="id:">id: aSymbol	id := aSymbol</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Testing</category><body package="SUnitToo" selector="isAvailable">isAvailable	"override to provide information on the	readiness of the resource"		^true</body><body package="SUnitToo" selector="isUnavailable">isUnavailable	"override to provide information on the	readiness of the resource"		^self isAvailable not</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Running</category><body package="SUnitToo" selector="setUp">setUp	"Does nothing. Subclasses should override this	to initialize their resource"</body><body package="SUnitToo" selector="signalInitializationError">signalInitializationError	^self class signalInitializationError</body><body package="SUnitToo" selector="tearDown">tearDown	"Does nothing. Subclasses should override this	to tear down their resource"</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Init / Release</category><body package="SUnitToo" selector="initialize">initialize	"VB: This method should not call setUp..."	self setUp</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>copied from TestCase</category><body package="SUnitToo" selector="assert:">assert: aBoolean 	aBoolean ifFalse: [self signalFailure: 'Assertion failed']</body><body package="SUnitToo" selector="assert:description:">assert: aBoolean description: aString	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo" selector="assert:description:resumable:">assert: aBoolean description: aString resumable: resumableBoolean	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo" selector="assert:equals:">assert: anObject equals: anotherObject	self assert: anObject = anotherObject		description: anObject printString, ' is not equal to ', anotherObject printString.</body><body package="SUnitToo" selector="assertBlock:raises:">assertBlock: aBlock raises: anExceptionalEvent 	^	[aBlock value.	false] on: anExceptionalEvent do: [:ex | ex return: true]</body><body package="SUnitToo" selector="assertCollection:equals:">assertCollection: actual equals: expected	"Specialized test method that generates a proper error message for collection"	^ self		assert: expected = actual		description: [ self comparingCollectionBetween: actual and: expected ]</body><body package="SUnitToo" selector="assertCollection:hasSameElements:">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |		additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self 		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description: (String streamContents: 			[:stream |			stream				nextPutAll: 'Given Collections do not match!'; lf;				tab; nextPutAll: 'additions : '; print: additionalElements asArray; lf;				tab; nextPutAll: 'missing: '; print: missingElements asArray; lf ])</body><body package="SUnitToo" selector="comparingCollectionBetween:and:">comparingCollectionBetween: left and: right	| additionalLeft additionalRight sortBlock|		"use a very slow sort block"	sortBlock := [ :a :b | a asString &lt;= b asString ].	additionalLeft := (left difference: right) sorted: sortBlock.	additionalRight := (right difference: left) sorted: sortBlock. 		^ String streamContents: [:stream |		stream			nextPutAll: 'Given Collections do not match. Got '; lf;			tab; nextPutAll: 'left := '; print: left; nextPut: $.; lf;			nextPutAll: ' instead of ';			tab; nextPutAll: ' right :='; print: left; nextPut: $.; lf.		left size = right size			ifFalse: [ 				stream 					nextPutAll: 'Collection size does not match: left='; 					print: left size;					nextPutAll: ' vs. right=';					print: right size; lf ].		additionalLeft isEmpty			ifFalse: [ 				stream 					nextPutAll: 'Got ';					print: additionalLeft size;					nextPutAll: ' additional element(s) in the left collection: ';					tab; print: additionalLeft  ].		additionalRight isEmpty			ifFalse: [ 				stream 					nextPutAll: 'Got ';					print: additionalRight size;					nextPutAll: ' additional element(s) in the right collection: ';					tab; print: additionalRight  ]]</body><body package="SUnitToo" selector="deny:">deny: aBoolean	self assert: aBoolean not</body><body package="SUnitToo" selector="deny:description:">deny: aBoolean description: aString	self assert: aBoolean not description: aString</body><body package="SUnitToo" selector="deny:description:resumable:">deny: aBoolean description: aString resumable: resumableBoolean	self assert: aBoolean not description: aString resumable: resumableBoolean</body><body package="SUnitToo" selector="fail">fail	^self assert: false</body><body package="SUnitToo" selector="fail:">fail: aDescriptionString	^self assert: false description: aDescriptionString</body><body package="SUnitToo" selector="should:">should: aBlock	self assert: aBlock value</body><body package="SUnitToo" selector="should:raise:">should: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent)</body><body package="SUnitToo" selector="should:raise:description:">should: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent)		description: aString.</body><body package="SUnitToo" selector="shouldnt:">shouldnt: aBlock	self deny: aBlock value</body><body package="SUnitToo" selector="shouldnt:raise:">shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent) not</body><body package="SUnitToo" selector="shouldnt:raise:description:">shouldnt: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent) not		description: aString.</body><body package="SUnitToo" selector="signalFailure:">signalFailure: aString 	FailedAssertion raiseSignal: aString</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>accessing</category><body package="SUnitToo" selector="current">current	^current ifNil: [current := self new]</body><body package="SUnitToo" selector="current:">current: aTestResource	current := aTestResource</body><body package="SUnitToo" selector="reset">reset		current ifNotNil: [[current tearDown] ensure: [current := nil]]</body><body package="SUnitToo" selector="resources">resources	"A Resource can bring in other resource (prerequisite resources basically) by return a collection of resources here that should be used in addition to the receiver."		^#()</body><body package="SUnitToo" selector="signalInitializationError">signalInitializationError	TestResourceUnavailable raiseSignal</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>instance creation</category><body package="SUnitToo" selector="new">new	^super new initialize</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>private</category><body package="SUnitToo" selector="appendResources:to:">appendResources: aResourceCollection to: aSequence	"Given aSequence, return a copy that has aResourceCollection AND all of its recursive resources added to aSequence. Avoid cycles and don't add duplicates. This is done as a utility method, because we can reuse the algorithm, and feed SUnit classic resources thru it as well."	| toAdd stack result |	stack := OrderedCollection new.	toAdd := OrderedCollection withAll: aResourceCollection.	[toAdd isEmpty] whileFalse: 			[| next |			next := toAdd removeFirst.			(stack includes: next) ifFalse: [stack add: next].			next resources				do: [:each | (stack includes: each) ifFalse: [toAdd addFirst: each]]].	result := aSequence.	stack do: 			[:eachResource |			(aSequence includes: eachResource)				ifFalse: [result := result copyWith: eachResource]].	^result</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>testing</category><body package="SUnitToo" selector="isAbstract">isAbstract	"Override to true if a TestResource subclass is Abstract and should not have	TestCase instances built from it"	^self == TestResource</body><body package="SUnitToo" selector="isAvailable">isAvailable	^self current notNil and: [self current isAvailable]</body><body package="SUnitToo" selector="isUnavailable">isUnavailable	^self isAvailable not</body></methods><methods><class-id>SequenceDiagram.AbstractEntity</class-id> <category>accessing</category><body package="SequenceDiagram" selector="name">name	^name</body><body package="SequenceDiagram" selector="name:">name: anObject	name := anObject</body><body package="SequenceDiagram" selector="realObject">realObject	^realObject</body><body package="SequenceDiagram" selector="realObject:">realObject: anObject	realObject := anObject</body></methods><methods><class-id>SequenceDiagram.AbstractEntity</class-id> <category>printing</category><body package="SequenceDiagram" selector="printOn:">printOn: aStream 	aStream &lt;&lt;self  class name asString .	aStream &lt;&lt; ' ('.	self name printOn: aStream.	aStream &lt;&lt; ')'</body></methods><methods><class-id>SequenceDiagram.AbstractEntity</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anObject 	^self class == anObject class and: [self name = anObject name]</body><body package="SequenceDiagram" selector="hash">hash	^self name hash</body></methods><methods><class-id>SequenceDiagram.AbstractEntity class</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="named:">named: aSymbol 	^(self new)		name: aSymbol;		yourself</body></methods><methods><class-id>SequenceDiagram.Package</class-id> <category>accessing</category><body package="SequenceDiagram" selector="classes">classes	^classes</body><body package="SequenceDiagram" selector="classes:">classes: anObject	classes := anObject</body></methods><methods><class-id>SequenceDiagram.Package</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="newClass:">newClass: className 	^(Class named: className)		package: self;		yourself</body></methods><methods><class-id>SequenceDiagram.Method</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activations">activations	^activations</body><body package="SequenceDiagram" selector="activations:">activations: anObject	activations value: anObject</body><body package="SequenceDiagram" selector="clazz">clazz	^clazz</body><body package="SequenceDiagram" selector="clazz:">clazz: anObject	clazz :=FMMultivalueLink 		on: self		update: #methods		from: self clazz		to: anObject</body></methods><methods><class-id>SequenceDiagram.Method</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	activations := FMMultivalueLink on: self opposite: #creator:</body></methods><methods><class-id>SequenceDiagram.Method</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="remove">remove	self activations copy do: #remove.	self clazz: nil</body></methods><methods><class-id>SequenceDiagram.Method</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anObject	 ^ super = anObject and: [ self clazz = anObject clazz ]</body><body package="SequenceDiagram" selector="hash">hash	^super hash bitXor: self clazz hash</body></methods><methods><class-id>LAN.Packet</class-id> <category>printing</category><body package="LANModel" selector="printOn:">printOn: aStream 	super printOn: aStream.	self originator notNil ifTrue: [aStream nextPutAll: ' coming from ' , self originator name printString].	aStream nextPutAll:		' addressed to ' , self addressee printString , 		' with contents: ' , self contents</body></methods><methods><class-id>LAN.Packet</class-id> <category>accessing</category><body package="LANModel" selector="addressee">addressee	"return the name of the node that is the addressee for this packet"	^addressee</body><body package="LANModel" selector="addressee:">addressee: anAddress	"set the name of the node that is the addressee for this packet"	addressee := anAddress.	self changed: #addressee</body><body package="LANModel" selector="contents">contents	"return the contents of the receiver"	^contents</body><body package="LANModel" selector="contents:">contents: aString	"set the contents of the receiver"	contents := aString.	self changed: #contents</body><body package="LANModel" selector="originator">originator	"I return the originator of the receiver"	^originator</body><body package="LANModel" selector="originator:">originator: aNode	"Set the originator of the receiver"	originator := aNode.	self changed: #originator</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>accessing</category><body package="SUnitToo" selector="addTest:">addTest: aTest		(resourceAndDefinitions		at: aTest resources		ifAbsentPut: [Set new]) add: aTest asDefinition</body><body package="SUnitToo" selector="addTests:">addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]</body><body package="SUnitToo" selector="definitionsForResources:">definitionsForResources: aResourceSet		^resourceAndDefinitions at: aResourceSet</body><body package="SUnitToo" selector="initialize">initialize	resourceAndDefinitions := Dictionary new</body><body package="SUnitToo" selector="resources">resources	^resourceAndDefinitions keys		fold: [:a :b | TestResource appendResources: a to: b]</body><body package="SUnitToo" selector="testCases:randomDo:">testCases: aSetOfDefintions randomDo: aBlock	"Backwards compatibility. To be removed soon."		^self testCasesFrom: aSetOfDefintions randomDo: aBlock</body><body package="SUnitToo" selector="testCasesFrom:do:">testCasesFrom: aSetOfDefinitiions do: aBlock	"This is the core enumeration point of a subset of my tests. For myself, I take the approach that random is best. Subclasses may override to change the order, or to change what is done at each point."		self testCasesFrom: aSetOfDefinitiions randomDo: aBlock</body><body package="SUnitToo" selector="testCasesFrom:randomDo:">testCasesFrom: aSetOfDefinitions randomDo: aBlock	"Enumerate the TestCases in aCollection in a random order. We keep a class variable to use the same random, that creating a new random each time, which is less random. This is the encouraged enumeration strategy. It makes sure that coupling errors don't accrue from running the tests in the same order each time."		| methods a b random |	random := self class random.	methods := aSetOfDefinitions asArray.	methods size * 3		timesRepeat:			[a := (random next * methods size) ceiling max: 1.			b := (random next * methods size) ceiling max: 1.			methods swap: a with: b].	methods do: [:each | aBlock value: each asTestCase]</body><body package="SUnitToo" selector="testCount">testCount		self isEmpty ifTrue: [^0].	^(resourceAndDefinitions collect: [:each | each size])		fold: [:a :b | a + b]</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>obsolete</category><body package="SUnitToo" selector="checkForResources">checkForResources	self resources 		do: [:res | res isAvailable ifFalse: [res signalInitializationError]]</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>running</category><body package="SUnitToo" selector="run">run	^self runTests</body><body package="SUnitToo" selector="runTests">runTests	^self runUsing: [:each | each run]</body><body package="SUnitToo" selector="runUsing:">runUsing: aBlock	"Run the suite through the tests, group them by resources which are are setup and reset for each grouping, but randomize their enumeration otherwise. aBlock is where the the test should actually be run."	^Results collectWhile: 			[resourceAndDefinitions keysAndValuesDo: 					[:resourceSet :definitions |					| allAvailable capturedEach |										[allAvailable := resourceSet allSatisfy: 									[:each |									capturedEach := each.									each isAvailable]]							on: Error							do: 								[:ex |								resourceSet reverseDo: [:each | each reset].								(TestResourceError newException)									failingResource: capturedEach;									resourceSet: resourceSet;									originalException: ex;									raiseSignal].					allAvailable						ifNotNil: 							[							[allAvailable								ifFalse: [TestResourceUnavailable raiseRequestWith: resourceSet]								ifTrue: [self testCasesFrom: definitions do: aBlock]]									ensure: [resourceSet reverseDo: [:each | each reset]]]]]</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>testing</category><body package="SUnitToo" selector="isEmpty">isEmpty	^resourceAndDefinitions isEmpty</body></methods><methods><class-id>SUnit.TestSuite class</class-id> <category>private</category><body package="SUnitToo" selector="random">random	^random ifNil: [random := Random standard]</body></methods><methods><class-id>SUnit.TestSuite class</class-id> <category>instance creation</category><body package="SUnitToo" selector="new">new	^super new initialize</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramAbstractModelTransformer</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	self subclassResponsibility</body><body package="SequenceDiagram" selector="runOn:">runOn: aModelHolder	self modelHolder: aModelHolder.	self run.</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramAbstractModelTransformer</class-id> <category>accessing</category><body package="SequenceDiagram" selector="modelHolder">modelHolder	^modelHolder</body><body package="SequenceDiagram" selector="modelHolder:">modelHolder: anObject	modelHolder := anObject</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerResetInstanceNumbers</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	self modelHolder classes do: 			[:cl | 			cl instances size = 1 				ifTrue: [cl instances first instanceId: nil]				ifFalse: [cl instances doWithIndex: [:item :idx | item instanceId: idx]]]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerUniqueInstance</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	| groupedClasses |	groupedClasses := self modelHolder instances 				groupedBy: [:inst | inst clazz].	groupedClasses do: [:aGroup | self mergeInstances: aGroup]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerUniqueInstance</class-id> <category>private</category><body package="SequenceDiagram" selector="mergeInstances:">mergeInstances: instances 	| newInstance |	instances size &lt; 2 ifTrue: [^self].	newInstance := (Instance new)				clazz: instances anyOne clazz;				activationsCreated: (instances flatCollect: #activationsCreated);				activationsReceived: (instances flatCollect: #activationsReceived);				instanceId: nil;				yourself.	instances do: #remove.	self modelHolder instances removeAll: instances.	self modelHolder instances add: newInstance</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerFilter</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	self modelHolder removeMethodsNamed: self methods</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerFilter</class-id> <category>accessing</category><body package="SequenceDiagram" selector="methods">methods	^methods</body><body package="SequenceDiagram" selector="methods:">methods: aCollectionOfMethods	methods := aCollectionOfMethods</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerFilter class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="onMethods:">onMethods: aListOfMethodsNames 	^(self new)		methods: aListOfMethodsNames;		yourself</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerLoopCondenser</class-id> <category>public</category><body package="SequenceDiagram" selector="add:inLoop:">add: anActivation inLoop: aLoop 	"I add an element in a loop. I should check if the element is already present in the loop. If it is I pass, if it is not I create an alternative case inside the loop"	| loopIndex loopItem |	loopPath incrementCurrentLoopIndex.	loopIndex := loopPath currentLoopIndex.	loopItem := aLoop atIndex: loopIndex				ifAbsent: 					[(aLoop activations isNotEmpty 						and: [aLoop activations last isAlternateCase]) 							ifTrue: [^ aLoop activations last add: anActivation]							ifFalse: [^aLoop add: anActivation]].	loopItem = anActivation 		ifTrue: 			["No add it is a loop"			^self].	"Everything is equal except the pcId -&gt; another method call to add."	(loopItem equalsExceptPcId: anActivation) 		ifTrue: [^aLoop add: anActivation].	"Else: create an alternate case"	self 		createOrEnhanceAlternateCase: loopItem		with: anActivation		in: aLoop</body><body package="SequenceDiagram" selector="insertActivation:">insertActivation: anActivation 	| loop |	(self isOutOfLoop and: [anActivation isLoopBegin not]) 		ifTrue: [result add: anActivation. ^ self].	loop := self searchOrCreateActivationLoop: anActivation.	"Transcript show: loopPath; cr."	anActivation isLoopBegin 		ifTrue: 			[(self is: anActivation theContinuationOf: loop) 				ifFalse: [loop incrementCounter. loopPath addNewLoopWithId: loop loopId]				ifTrue: [loopPath addLoopId: loop loopId pc: loop activationIndexOfLastPc].			self add: anActivation inLoop: loop.			self updateState.			^loop].	anActivation isLoopEnd 		ifTrue: 			[self add: anActivation inLoop: loop.			loop lastPc: anActivation pcId.			loopPath removeLastLoop.			self updateState.			^loop].	self isInLoop ifTrue: [self add: anActivation inLoop: loop]</body><body package="SequenceDiagram" selector="isOutOfLoop">isOutOfLoop 	^self state = #outOfLoop</body><body package="SequenceDiagram" selector="run">run	self reset.	state := #outOfLoop.	"#outOfLoop #inLoop"	self modelHolder activations do: [:act | self insertActivation: act].	self modelHolder activations: result</body><body package="SequenceDiagram" selector="searchOrCreateActivationLoop:">searchOrCreateActivationLoop: anActivation 	"I am searching the loop depending of the loopPath in the result. If not found, I append a new one"	| loopIdx res |	loopIdx := loopPath currentPathIndex.	loopPath resetPathIndex.	res := self 				searchLoopWith: loopPath				parentConatainer: result				loopId: anActivation loopId.	loopPath currentPathIndex: loopIdx.	^res</body><body package="SequenceDiagram" selector="updateState">updateState	"I am updating the state depending of the loop path"	state := loopPath state.</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerLoopCondenser</class-id> <category>accessing</category><body package="SequenceDiagram" selector="state">state	^state</body><body package="SequenceDiagram" selector="state:">state: anObject	state := anObject</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerLoopCondenser</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="addNewLoopWithId:in:">addNewLoopWithId: loopIdToInsert in: theParentContainer 	| loop |	loop := (ActivationLoop new)				loopId: loopIdToInsert;				yourself.	theParentContainer add: loop.	^loop</body><body package="SequenceDiagram" selector="closeLoop:lastInserted:inSwitch:">closeLoop: aLoop lastInserted: anActivation inSwitch: aSwtich 	"Fast solution: We put all the items that are after the loop inside the first case. and we sort it after"	| firstIndex oldActivations |	firstIndex := aLoop findIndexOfItemSuchThat: [:e | e == aSwtich switch].	firstIndex ifNil: [^nil].	oldActivations := aLoop activations 				removeLast: aLoop activations size - firstIndex.	aSwtich addAllInFirstCase: oldActivations</body><body package="SequenceDiagram" selector="createOrEnhanceAlternateCase:with:in:">createOrEnhanceAlternateCase: loopItem with: anActivation in: aLoop 	| previousItem actSwitch newCase oldCase |	loopItem isAlternateCase 		ifTrue: 			[previousItem := aLoop previousItem: loopItem activationsPossibilities first .			previousItem ifNotNil: 					[previousItem isAlternateCase 						ifTrue: 							["if the previous one is also an alternate case, we just add it to the current case of the switch?"							^previousItem switch currentCase switch add: anActivation]].			"In this case, create a new case"			^loopItem switch addNewCase add: anActivation]		ifFalse: 			[previousItem := aLoop previousItem: loopItem.			previousItem ifNotNil: 					[previousItem isAlternateCase 						ifTrue: 							["The previous item is a switch and we need to add the current activation to it."							previousItem addInCurrentCase: anActivation.							previousItem addInFirstCase: loopItem.							aLoop remove: loopItem.							anActivation isLoopEnd 								ifTrue: 									[self 										closeLoop: aLoop										lastInserted: anActivation										inSwitch: previousItem].							loopItem isLoopEnd 								ifTrue: 									[self 										closeLoop: aLoop										lastInserted: loopItem										inSwitch: previousItem].							^loopItem]].			"One create a new alternatecase remove the loopItem of the loop"			actSwitch := ActivationSwitch new.			oldCase := actSwitch addNewCase.			oldCase add: loopItem.			newCase := actSwitch addNewCase.			newCase add: anActivation.			aLoop replace: loopItem with: actSwitch]</body><body package="SequenceDiagram" selector="is:theContinuationOf:">is: anActivation theContinuationOf: aLoop 	| lastAct |	aLoop activations ifEmpty: [^false].	lastAct := aLoop activations last.	anActivation pcId &lt; aLoop lastPc ifTrue: [aLoop isFull: true].	^lastAct isLoopEnd and: [aLoop lastPc &lt; anActivation pcId]</body><body package="SequenceDiagram" selector="isInLoop">isInLoop	^self state = #inLoop</body><body package="SequenceDiagram" selector="searchLoopWith:parentConatainer:loopId:">searchLoopWith: aLoopPath parentConatainer: theParentContainer loopId: loopIdToInsert 	| actLoop loopId |	^aLoopPath atPathEnd 		ifTrue: 			["Not Found or loop closed and pc different"			^theParentContainer detect: [:act | act loopId = loopIdToInsert]				ifNone: [^self addNewLoopWithId: loopIdToInsert in: theParentContainer]]		ifFalse: 			[loopId := aLoopPath currentLoopId.			actLoop := theParentContainer detect: [:act | act loopId = loopId]						ifNone: [^self addNewLoopWithId: loopIdToInsert in: theParentContainer].			loopPath incrementPathIndex.			aLoopPath atPathEnd 				ifTrue: 					[loopIdToInsert ifNil: [^actLoop].					loopIdToInsert = actLoop loopId 						ifTrue: [^actLoop]						ifFalse: 							[^actLoop activations detect: [:act | act loopId = loopIdToInsert]								ifNone: 									[loopPath incrementCurrentLoopIndex.									^self addNewLoopWithId: loopIdToInsert in: actLoop]]].					self 				searchLoopWith: aLoopPath				parentConatainer: actLoop activations				loopId: loopIdToInsert]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelTransformerLoopCondenser</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	self reset</body><body package="SequenceDiagram" selector="reset">reset	result := OrderedCollection new.	loopPath := LoopPath new</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	transformers := OrderedCollection new</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram</class-id> <category>accessing</category><body package="SequenceDiagram" selector="block">block	^block</body><body package="SequenceDiagram" selector="block:">block: anObject	block := anObject</body><body package="SequenceDiagram" selector="packages">packages	^packages</body><body package="SequenceDiagram" selector="packages:">packages: anObject	packages := anObject</body><body package="SequenceDiagram" selector="stream">stream	^stream</body><body package="SequenceDiagram" selector="stream:">stream: anObject	stream := anObject</body><body package="SequenceDiagram" selector="transformers">transformers	^transformers</body><body package="SequenceDiagram" selector="transformers:">transformers: anObject	transformers := anObject</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram</class-id> <category>public</category><body package="SequenceDiagram" selector="run">run	| result instance |	instance := SequenceDiagramCreator run: self block onPackages: self packages.	result := instance modelHolder.	self transform: result.	SequenceDiagramWriter runOn: self stream with: result.	^instance blockExecutionResult</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram</class-id> <category>private</category><body package="SequenceDiagram" selector="transform:">transform: aModelHolder	self transformers do: [:t | t runOn: aModelHolder ]</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram</class-id> <category>public-unsafe</category><body package="SequenceDiagram" selector="postExecution">postExecution	| result |	result := seqDiagramCreator postExecution.	self transform: result.	SequenceDiagramWriter runOn: self stream with: result</body><body package="SequenceDiagram" selector="prepare">prepare	seqDiagramCreator := SequenceDiagramCreator 				prepareOnPackages: self packages</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="run:on:fileIn:">run: aBlock on: aCollectionOfPackageNames fileIn: aFileName 	| aFile stream result |	aFile := aFileName asFilename.		[stream := aFile writeStream.	result := self 		run: aBlock		on: aCollectionOfPackageNames		writeIn: stream] 			ensure: [stream ifNotNil: [:e | e  close]].	^result</body><body package="SequenceDiagram" selector="run:on:fileIn:withTransformers:">run: aBlock on: aCollectionOfPackageNames fileIn: aFileName withTransformers: aCollectionOfTransformers 	| aFile stream result |	aFile := aFileName asFilename.		[stream := aFile writeStream.	result := self 		run: aBlock		on: aCollectionOfPackageNames		writeIn: stream		withTransformers: aCollectionOfTransformers] 			ensure: [stream ifNotNil: [:e | e close]].	^result</body><body package="SequenceDiagram" selector="run:on:writeIn:">run: aBlock on: aCollectionOfPackageNames writeIn: aStream 	^(self new)		block: aBlock;		packages: aCollectionOfPackageNames;		stream: aStream;		run</body><body package="SequenceDiagram" selector="run:on:writeIn:withTransformers:">run: aBlock on: aCollectionOfPackageNames writeIn: aStream withTransformers: aCollectionOfModelTransformers 	^(self new)		block: aBlock;		packages: aCollectionOfPackageNames;		stream: aStream;		transformers: aCollectionOfModelTransformers;		run</body></methods><methods><class-id>SequenceDiagram.SequenceDiagram class</class-id> <category>private</category><body package="SequenceDiagram" selector="prepareOnPackages:writeIn:">prepareOnPackages: aCollectionOfPackageNames writeIn: aStream 	^(self new)		stream: aStream;		packages: aCollectionOfPackageNames;		prepare;		yourself</body><body package="SequenceDiagram" selector="prepareOnPackages:writeIn:withTransformers:">prepareOnPackages: aCollectionOfPackageNames writeIn: aStream withTransformers: transformers	^(self new)		stream: aStream;		packages: aCollectionOfPackageNames;		transformers: transformers;		prepare;		yourself</body></methods><methods><class-id>SequenceDiagram.Class</class-id> <category>accessing</category><body package="SequenceDiagram" selector="addMethod:">addMethod: aMethod 	self methods add: aMethod</body><body package="SequenceDiagram" selector="instances">instances	^instances</body><body package="SequenceDiagram" selector="instances:">instances: anObject	instances := anObject</body><body package="SequenceDiagram" selector="methods">methods	^methods</body><body package="SequenceDiagram" selector="methods:">methods: anObject	methods := anObject</body><body package="SequenceDiagram" selector="package">package	^package</body><body package="SequenceDiagram" selector="package:">package: anObject	package := anObject</body></methods><methods><class-id>SequenceDiagram.Class</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	instances := FMMultivalueLink on: self opposite: #clazz:.	methods := FMMultivalueLink on: self opposite: #clazz:</body></methods><methods><class-id>SequenceDiagram.Class</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="addInstance:">addInstance: anInstance	self instances add: anInstance</body><body package="SequenceDiagram" selector="methodNamed:ifAbsentAdd:">methodNamed: aName ifAbsentAdd: aBlock 	^self methods detect: [:m | m name = aName] ifNone: aBlock</body><body package="SequenceDiagram" selector="newInstance">newInstance	^ Instance from: self</body><body package="SequenceDiagram" selector="newMethod:">newMethod: methodName 	| meth |	meth := (Method named: methodName)				clazz: self;				yourself.	^meth</body></methods><methods><class-id>SequenceDiagram.Class</class-id> <category>comparing</category><body package="SequenceDiagram" selector="=">= anObject	 ^ super = anObject and: [ self package = anObject package ]</body><body package="SequenceDiagram" selector="hash">hash	^super hash bitXor: self package hash</body></methods><methods><class-id>SUnit.Results</class-id> <category>bw compat SUnit APIs</category><body package="SUnitToo" selector="errorCount">errorCount	^self errorsCount</body><body package="SUnitToo" selector="failureCount">failureCount	^self failedCount</body><body package="SUnitToo" selector="runCount">runCount	^self ranCount</body></methods><methods><class-id>SUnit.Results</class-id> <category>accessing</category><body package="SUnitToo" selector="addError:">addError: aResult 	errors add: aResult</body><body package="SUnitToo" selector="addFailure:">addFailure: aResult 	failures add: aResult</body><body package="SUnitToo" selector="addPass:">addPass: aResult 	(failures anySatisfy: [:res | res definition = aResult definition]) 		ifFalse: [passes add: aResult]</body><body package="SUnitToo" selector="addResult:">addResult: aResult 	aResult copy addTo: self</body><body package="SUnitToo" selector="cease">cease	TestCase unsubscribe: self</body><body package="SUnitToo" selector="collect">collect	TestCase 		when: Result		send: #addResult:		to: self</body><body package="SUnitToo" selector="collectWhile:">collectWhile: aBlock 	self collect.	aBlock ensure: [self cease]</body><body package="SUnitToo" selector="defects">defects	^(OrderedCollection new)		addAll: self errors;		addAll: self failures;		yourself</body><body package="SUnitToo" selector="errors">errors	^errors</body><body package="SUnitToo" selector="errorsCount">errorsCount	^errors size</body><body package="SUnitToo" selector="failedCount">failedCount	^failures size</body><body package="SUnitToo" selector="failures">failures	^failures</body><body package="SUnitToo" selector="passCount">passCount	^passes size</body><body package="SUnitToo" selector="passes">passes	^passes</body><body package="SUnitToo" selector="ranCount">ranCount	^self passCount + self failedCount + self errorsCount</body></methods><methods><class-id>SUnit.Results</class-id> <category>testing</category><body package="SUnitToo" selector="allPassed">allPassed	^self hasErrors not and: [self hasFailures not]</body><body package="SUnitToo" selector="hasErrors">hasErrors	^errors notEmpty</body><body package="SUnitToo" selector="hasFailures">hasFailures	^failures notEmpty</body><body package="SUnitToo" selector="isEmpty">isEmpty	^self ranCount isZero</body></methods><methods><class-id>SUnit.Results</class-id> <category>initialize-release</category><body package="SUnitToo" selector="initialize">initialize	errors := Set new.	passes := Set new.	failures := Set new</body></methods><methods><class-id>SUnit.Results</class-id> <category>printing</category><body package="SUnitToo" selector="countSelectors">countSelectors	^#(#ranCount #failedCount #errorsCount)</body><body package="SUnitToo" selector="printOn:">printOn: aStream	aStream		nextPutAll:			(self allPassed				ifTrue: ['Passed: ']				ifFalse: ['Failed: ']).	(self countSelectors reject: [:each | (self perform: each) isZero])		do:			[:each | 			aStream				print: (self perform: each);				space;				nextPutAll: (each allButLast: 'Count' size)]		separatedBy: [aStream nextPutAll: ', ']</body></methods><methods><class-id>SUnit.Results class</class-id> <category>instance creation</category><body package="SUnitToo" selector="collectWhile:">collectWhile: aBlock 	^self new collectWhile: aBlock</body><body package="SUnitToo" selector="new">new	^super new initialize</body></methods><methods><class-id>LAN.WorkStation</class-id> <category>sending-receiving</category><body package="LANModel" selector="accept:">accept: thePacket 	"accept the packet and see if I am the originator. If this is the case, take the packet out because the 	addressee is unknown. Print this on the Transcript"	thePacket originator = self		ifTrue: [Transcript show: 'The receiver of following packet does not exist:'; cr; show: thePacket printString; cr]		ifFalse: [self send: thePacket]</body><body package="LANModel" selector="originate:">originate: thePacket 	"This is how packets get inserted into the network. This is a likely method to be rwritten to permit 	packets to be entered in various ways. Currently, I assume that someone alse creates the packet, 	and passes it to me as an argument."	thePacket originator: self.	self send: thePacket</body></methods><methods><class-id>LAN.WorkStation</class-id> <category>outputting</category><body package="LANModel" selector="name">name	"added for candidate invocations operator test"		^super name</body></methods><methods><class-id>LAN.WorkStation</class-id> <category>testing</category><body package="LANModel" selector="canOriginate">canOriginate	^true</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramLoopTest</class-id> <category>tests</category><body package="SequenceDiagramTest" selector="testAtIndexWithDoubleLoop">testAtIndexWithDoubleLoop	| loop idx |	loop := self doubleLoop.	idx := loop atIndex: 3 ifAbsent: [].	self assert: idx equals: theItemThatIsInTheLoop</body><body package="SequenceDiagramTest" selector="testAtIndexWithLoopOnly">testAtIndexWithLoopOnly	| loop idx |	loop := self simpleLoop.	idx := loop atIndex: 2 ifAbsent: [].	self assert: idx equals: theItemThatIsInTheLoop</body><body package="SequenceDiagramTest" selector="testAtIndexWithNotInDoubleLoop">testAtIndexWithNotInDoubleLoop	| loop passed |	loop := self doubleLoop.	passed := false.	loop atIndex: 7 ifAbsent: [ passed := true ].	self assert: passed</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithDoubleLoop">testFindIndexOfItemSuchThatWithDoubleLoop	| loop idx |	loop := self doubleLoop.	idx := loop findIndexOfItemSuchThat: [:item | item == theItemThatIsInTheLoop ].	self assert: idx equals: 3</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithLoopOnly">testFindIndexOfItemSuchThatWithLoopOnly	| loop idx |	loop := self simpleLoop.	idx := loop findIndexOfItemSuchThat: [:item | item == theItemThatIsInTheLoop ].	self assert: idx equals: 2</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithLoopWithSwitch">testFindIndexOfItemSuchThatWithLoopWithSwitch	| loop idx |	loop := self simpleLoopWithSwitch.	idx := loop findIndexOfItemSuchThat: [:item | item == theItemThatIsInTheLoop ].	self assert: idx equals: 3</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithLoopWithSwitchAfter">testFindIndexOfItemSuchThatWithLoopWithSwitchAfter	| loop idx |	loop := self simpleLoopWithSwitch.	idx := loop findIndexOfItemSuchThat: [:item | item == theItemThatIsAfterTheSwitch ].	self assert: idx equals: 5</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithNotInDoubleLoop">testFindIndexOfItemSuchThatWithNotInDoubleLoop	| loop idx |	loop := self doubleLoop.	idx := loop findIndexOfItemSuchThat: [:item | item == Activation new ].	self assert: idx equals: nil</body><body package="SequenceDiagramTest" selector="testFindIndexOfItemSuchThatWithNotInLoop">testFindIndexOfItemSuchThatWithNotInLoop	| loop idx |	loop := self simpleLoop.	idx := loop findIndexOfItemSuchThat: [:item | item == Activation new ].	self assert: idx equals: nil</body><body package="SequenceDiagramTest" selector="testNumberOfItemsWithLoopWithSwitch">testNumberOfItemsWithLoopWithSwitch	| loop |	loop := self simpleLoopWithSwitch.	self assert: loop numberOfItems equals: 5</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramLoopTest</class-id> <category>accessing</category><body package="SequenceDiagramTest" selector="doubleLoop">doubleLoop	^(ActivationLoop new)		add: Activation new;		add: ((ActivationLoop new)					add: Activation new;					add: theItemThatIsInTheLoop;					add: Activation new;					yourself);		add: Activation new;		yourself</body><body package="SequenceDiagramTest" selector="simpleLoop">simpleLoop	^ActivationLoop new 		add: Activation new;		add: theItemThatIsInTheLoop;		add: Activation new;		yourself</body><body package="SequenceDiagramTest" selector="simpleLoopWithSwitch">simpleLoopWithSwitch	| sw |	sw:= ActivationSwitch new .	sw addNewCase add: Activation new; add: Activation new.	sw addNewCase add: Activation new; add: theItemThatIsInTheLoop; add: Activation new.	^ActivationLoop new 		add: Activation new;		add: sw ;		add: theItemThatIsAfterTheSwitch;		yourself</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramLoopTest</class-id> <category>running</category><body package="SequenceDiagramTest" selector="setUp">setUp	theItemThatIsInTheLoop := Activation new.	theItemThatIsAfterTheSwitch := Activation new</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelHolder</class-id> <category>As yet unclassified</category><body package="SequenceDiagram" selector="addNewActivationFromContext:direction:">addNewActivationFromContext: aPrimaryContext direction: aDirection 	| aContext rcvClazzInstance sndClazzInstance method act |	^semaphore critical: 			[aContext := aDirection = #out 						ifFalse: [aPrimaryContext]						ifTrue: [aPrimaryContext sender sender sender].			rcvClazzInstance := self createOrGetClazzInstance: (aDirection = #out 								ifFalse: [aContext receiver]								ifTrue: [aContext receiver]).			sndClazzInstance := self 						createOrGetClazzInstance: (aContext sender receiver isBlockClosure 								ifTrue: [aContext supposedHome receiver]								ifFalse: [aContext sender receiver]).			"(rcvClazzInstance = sndClazzInstance and: [aDirection = #out]) 				ifTrue: [^self]."			method := self createOrGetMethod: aContext method on: rcvClazzInstance.			act := Activation 						newCreator: sndClazzInstance						call: method						to: rcvClazzInstance						direction: aDirection.			activations add: act.			act]</body><body package="SequenceDiagram" selector="addNewActivationFromContext:direction:process:">addNewActivationFromContext: aPrimaryContext direction: aDirection process: aProcessId 	| aContext rcvClazzInstance sndClazzInstance method act |	^semaphore critical: 			[aContext := aDirection = #out 						ifFalse: [aPrimaryContext]						ifTrue: [aPrimaryContext sender sender sender].			rcvClazzInstance := self createOrGetClazzInstance: (aDirection = #out 								ifFalse: [aContext receiver]								ifTrue: [aContext receiver]).			sndClazzInstance := self 						createOrGetClazzInstance: (aContext sender receiver isBlockClosure 								ifTrue: [aContext supposedHome receiver]								ifFalse: [aContext sender receiver]).			"(rcvClazzInstance = sndClazzInstance and: [aDirection = #out]) 				ifTrue: [^self]."			method := self createOrGetMethod: aContext method on: rcvClazzInstance.			act := (Activation 						newCreator: sndClazzInstance						call: method						to: rcvClazzInstance						direction: aDirection)						process: aProcessId;						yourself.			activations add: act.			act]</body><body package="SequenceDiagram" selector="allInstances">allInstancesself halt.</body><body package="SequenceDiagram" selector="clazzNamed:">clazzNamed: aName	^self classes detect: [:e | e name = aName]</body><body package="SequenceDiagram" selector="createOrGetClazz:">createOrGetClazz: aClassName	^ self classes at: aClassName ifAbsentPut: [		Class named: aClassName	] </body><body package="SequenceDiagram" selector="createOrGetClazzInstance:">createOrGetClazzInstance: aClassInstance 	| clazz inst |	^self instances at: aClassInstance		ifAbsentPut: 			[clazz := self createOrGetClazz: aClassInstance class fullName.			inst := clazz newInstance.			clazz addInstance: inst.			inst]</body><body package="SequenceDiagram" selector="createOrGetMethod:on:">createOrGetMethod: aMethod on: aClazzInstance 	| methName inst |	methName := self retrieveMethodName: aMethod.	^aClazzInstance clazz methodNamed: methName		ifAbsentAdd: 			[inst := aClazzInstance clazz newMethod: methName.			self methods add: inst]</body><body package="SequenceDiagram" selector="numberOfActivations">numberOfActivations	^self activations size</body><body package="SequenceDiagram" selector="numberOfInstances">numberOfInstances	^ self instances size</body><body package="SequenceDiagram" selector="numberOfMethods">numberOfMethods	^self methods size</body><body package="SequenceDiagram" selector="removeMethodsNamed:">removeMethodsNamed: aListOfMethodNames 	| toRemove actsToRemove |	toRemove := self methods 				select: [:m | aListOfMethodNames includes: m name].	actsToRemove := toRemove flatCollect: #activations.	toRemove do: #remove.	self methods removeAll: toRemove.	self activations removeAll: actsToRemove</body><body package="SequenceDiagram" selector="retrieveMethodName:">retrieveMethodName: aCompiledBlock 	^aCompiledBlock homeMethod selector</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelHolder</class-id> <category>accessing</category><body package="SequenceDiagram" selector="activations">activations	^activations</body><body package="SequenceDiagram" selector="activations:">activations: anObject	activations := anObject</body><body package="SequenceDiagram" selector="classes">classes	^classes</body><body package="SequenceDiagram" selector="classes:">classes: anObject	classes := anObject</body><body package="SequenceDiagram" selector="instances">instances	^instances</body><body package="SequenceDiagram" selector="instances:">instances: anObject	instances := anObject</body><body package="SequenceDiagram" selector="methods">methods	^methods</body><body package="SequenceDiagram" selector="methods:">methods: anObject	methods := anObject</body></methods><methods><class-id>SequenceDiagram.SequenceDiagramModelHolder</class-id> <category>initialize-release</category><body package="SequenceDiagram" selector="clean">clean	instances := instances values.	classes := classes values.	</body><body package="SequenceDiagram" selector="initialize">initialize	super initialize.	semaphore := Semaphore forMutualExclusion.	activations := OrderedCollection new.	instances := IdentityDictionary new.	classes := Dictionary new.	methods := OrderedCollection new</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>initialize-release</category><body package="SUnitToo" selector="testCase:">testCase: aTestCase 	definition := aTestCase asDefinition</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>accessing</category><body package="SUnitToo" selector="addTo:">addTo: aResults 	self subclassResponsibility</body><body package="SUnitToo" selector="asTestCase">asTestCase	^definition asTestCase</body><body package="SUnitToo" selector="definition">definition	^definition</body><body package="SUnitToo" selector="definition:">definition: anObject	definition := anObject</body><body package="SUnitToo" selector="method">method	^definition method</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>comparing</category><body package="SUnitToo" selector="=">= aResult 	^self class == aResult class and: [definition = aResult definition]</body><body package="SUnitToo" selector="hash">hash	^definition hash</body></methods><methods><class-id>SUnit.TestCaseAnnouncement class</class-id> <category>instance creation</category><body package="SUnitToo" selector="testCase:">testCase: aTestCase 	^self new testCase: aTestCase</body></methods><methods><class-id>SUnit.Result</class-id> <category>accessing</category><body package="SUnitToo" selector="addTo:">addTo: aResults 	self subclassResponsibility</body><body package="SUnitToo" selector="asTestCase">asTestCase	^definition asTestCase</body><body package="SUnitToo" selector="definition">definition	^definition</body><body package="SUnitToo" selector="definition:">definition: anObject	definition := anObject</body><body package="SUnitToo" selector="method">method	^definition method</body></methods><methods><class-id>SUnit.Result</class-id> <category>comparing</category><body package="SUnitToo" selector="=">= aResult 	^self class == aResult class and: [definition = aResult definition]</body><body package="SUnitToo" selector="hash">hash	^definition hash</body></methods><methods><class-id>SUnit.Result</class-id> <category>initialize-release</category><body package="SUnitToo" selector="testCase:">testCase: aTestCase 	definition := aTestCase asDefinition</body></methods><methods><class-id>SUnit.Result class</class-id> <category>instance creation</category><body package="SUnitToo" selector="testCase:">testCase: aTestCase 	^self new testCase: aTestCase</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>accessing</category><body package="SUnitToo" selector="exception">exception	^exception</body><body package="SUnitToo" selector="exception:">exception: anObject	exception := anObject</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>copying</category><body package="SUnitToo" selector="postCopy">postCopy	super postCopy.	exception := nil</body></methods><methods><class-id>SUnit.Failure</class-id> <category>accessing</category><body package="SUnitToo" selector="addTo:">addTo: aResults 	aResults addFailure: self</body></methods><methods><class-id>SUnit.SomeError</class-id> <category>accessing</category><body package="SUnitToo" selector="addTo:">addTo: aResults 	aResults addError: self</body></methods><methods><class-id>SUnit.Pass</class-id> <category>accessing</category><body package="SUnitToo" selector="addTo:">addTo: aResults 	aResults addPass: self</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>converting</category><body package="SUnitToo" selector="asTestCase">asTestCase	^inheritingClass selector: selector</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SUnitToo" selector="hasAttributeSelector:">hasAttributeSelector: nope 	^false</body></methods><methods><class-id>Core.Error</class-id> <category>sunit</category><body package="SUnitToo" selector="occurredForTest:">occurredForTest: aTestCase 	"double dispatch back to the test"	aTestCase announceError: self.	self return </body></methods><methods><class-id>Core.Object class</class-id> <category>testing</category><body package="SUnitToo" selector="isTestCase">isTestCase	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SUnitToo" selector="isTestCase">isTestCase	^self class isTestCase</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>testing</category><body package="SUnitToo" selector="hasAttributeSelector:">hasAttributeSelector: aSymbol 	^self attributeMessages anySatisfy: [:each | each selector = aSymbol]</body></methods><methods><class-id>Kernel.AnnotatedMethod</class-id> <category>accessing</category><body package="SUnitToo" selector="hasAttributeSelector:">hasAttributeSelector: aSymbol 	^self attributeMessages anySatisfy: [:each | each selector = aSymbol]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="PharoKernelAdditionsPkg" selector="cull:">cull: anArg	"Execute the receiver with one or zero arguments depending on the receiver"	"([ 12 ] cull: 13)	&gt;&gt;&gt; 12 	"	"([:x | x + 12] cull: 3)	&gt;&gt;&gt; 15	"		^self numArgs = 0 		ifTrue: [self value]		ifFalse: [self value: anArg]</body><body package="PharoKernelAdditionsPkg" selector="cull:cull:">cull: firstArg cull: secondArg	"Execute the receiver with one or two arguments depending on the receiver"	"([:x | x + 1] cull: 13 cull: 12)	&gt;&gt;&gt; 14	"	"([:x :y | x + y] cull: 3 cull: 2)	&gt;&gt;&gt; 5	"	^self numArgs &lt; 2 		ifTrue: [self cull: firstArg]		ifFalse: [self value: firstArg value: secondArg]</body></methods><methods><class-id>Core.Symbol</class-id> <category>accessing</category><body package="PharoKernelAdditionsPkg" selector="cull:">cull: anObject 	^anObject perform: self.</body><body package="PharoKernelAdditionsPkg" selector="value:">value: anObject 	^anObject perform: self.</body></methods><methods><class-id>Core.Object</class-id> <category>asserting</category><body package="PharoKernelAdditionsPkg" selector="assert:">assert: aBlock	| inspector source range |	aBlock value == true ifFalse:		[inspector := aBlock method inspectorClass inspect: aBlock.		source := aBlock method homeMethod getSource.		range := inspector pcRange.		self error: (#AssertionFailed &lt;&lt; #dialogs &gt;&gt; 'assertion failed &lt;1s&gt;'			expandMacrosWith: (source copyFrom: range first to: range last))]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="PharoKernelAdditionsPkg" selector="hex">hex    " an alternate implementation was | result stream |	result := String new: self size * 2.	stream := result writeStream.	1 to: self size do: [ :ix | |each|		each := self at: ix.		stream			nextPut: ('0123456789ABCDEF' at: each // 16 + 1);			nextPut: ('0123456789ABCDEF' at: each \\ 16 + 1)].    ^ result"		"Answer a hexa decimal representation of the receiver"	| string v index map |	map := '0123456789abcdef'.	string := String new: self size * 2. "hex"	index := 0.	1 to: self size do: [ :i |		v := self at: i.		string at: (index := index + 1) put: (map at: (v bitShift: -4) + 1).		string at: (index := index + 1) put: (map at: (v bitAnd: 15) + 1)].	^string</body></methods><methods><class-id>Core.ByteArray</class-id> <category>initialize-release</category><body package="PharoKernelAdditionsPkg" selector="readHexFrom:">readHexFrom: aStream	"Initialize the receiver from a hexadecimal string representation"	| map v ch value |	map := '0123456789abcdefABCDEF'.	1 to: self size do: [ :i |		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := v bitShift: 4.		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := value + v.		self at: i put: value].</body></methods><methods><class-id>Core.Float class</class-id> <category>constants access</category><body package="PharoKernelAdditionsPkg" selector="emax">emax	"Answer exponent of maximal representable value"		^38</body><body package="PharoKernelAdditionsPkg" selector="emin">emin	"Answer exponent of minimal normalized representable value"		^-37</body></methods><methods><class-id>Core.Integer</class-id> <category>private</category><body package="PharoCollectionsFeaturesPkg" selector="printOn:base:nDigits:">printOn: aStream base: b nDigits: n 	^self 		printOn: aStream		base: b		digitsToPad: n		highDigit: n</body></methods><methods><class-id>Core.Integer</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="putOn:">putOn: aStream	aStream isBinary		ifTrue: [ self asByteArray do: [ :each | aStream nextPut: each ] ]		ifFalse: [ self asString putOn: aStream ]</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="allRangesOfSubstring:">allRangesOfSubstring: aSubstring	^ Array streamContents: [:s | | start subSize |		start := 1.		subSize := aSubstring size.		[start isZero]			whileFalse: [ start := self findString: aSubstring startingAt: start.				start &gt; 0 					ifTrue: [s nextPut: (start to: start + subSize - 1).						start := start + subSize]]]</body></methods><methods><class-id>Core.String</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="lines">lines	"NB: not imported from Pharo but have the same meaning"	^self 		substrings: (OrderedCollection with: Character cr with: Character lf)</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="numberOfOccurencesOf:">numberOfOccurencesOf: aSubstring	^(self allRangesOfSubstring: aSubstring) size</body></methods><methods><class-id>Core.String</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="putOn:">putOn: aStream	aStream nextPutAll: self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="PharoCollectionsFeaturesPkg" selector="substrings:">substrings: separators	"Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."	| substrings substringStart |	substrings := (Array new: 10) writeStream.	substringStart := nil.	1 to: self size do: [ :i | 		| nextChar |		nextChar := self at: i.		(separators includes: nextChar)			ifTrue: [				substringStart					ifNotNil: [						substrings nextPut: (self copyFrom: substringStart to: i - 1).						substringStart := nil ] ]			ifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].	substringStart		ifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].	^ substrings contents</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="anyOne">anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:each | ^ each]</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="PharoCollectionsFeaturesPkg" selector="asDictionary">asDictionary	^ self as: Dictionary</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="associationsDo:">associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock</body><body package="PharoCollectionsFeaturesPkg" selector="difference:">difference: aCollection	"Answer the set theoretic difference of two collections."	"#(a b c d e f) difference:  #(a b z k)	=&gt; #(#f #d #e #c)		#(a b z k) difference: #(a b c d e f) 	=&gt; #(#k #z) 	"	| set |	set := self asSet.	aCollection do: [ :each | set remove: each ifAbsent: [  ] ].	^ self species withAll: set asArray</body><body package="PharoCollectionsFeaturesPkg" selector="flatCollect:">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"		^ self flatCollect: aBlock as: self species</body><body package="PharoCollectionsFeaturesPkg" selector="flatCollect:as:">flatCollect: aBlock as: aCollectionClass	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"	| col |	col := aCollectionClass new: self size. 		self do: [ :each |		col addAll: (aBlock value: each) ].	^col</body><body package="PharoCollectionsFeaturesPkg" selector="flatCollectAsSet:">flatCollectAsSet: aBlock	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"		^ self flatCollect: aBlock as: Set</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="PharoCollectionsFeaturesPkg" selector="identityIncludes:">identityIncludes: anObject 	"Answer whether anObject is one of the receiver's elements."	self do: [:each | anObject == each ifTrue: [^true]].	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="intersection:">intersection: aCollection	"Answer the set theoretic intersection of two collections."	| set outputSet |		set := self asSet.	outputSet := Set new.		aCollection do: [ :each|		((set includes: each) and: [(outputSet includes: each) not])			ifTrue: [ 				outputSet add: each]].			^ self species withAll: outputSet asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="PharoCollectionsFeaturesPkg" selector="removeAll">removeAll	"Remove each element from the receiver and leave it empty.	ArrayedCollections cannot respond to this message.	There are two good reasons why a subclass should override this message:	1) the subclass does not support being modified while being iterated	2) the subclass provides a much faster way than iterating through each element"	self do: [:each | self remove: each].</body></methods><methods><class-id>Core.Collection</class-id> <category>sorting</category><body package="PharoCollectionsFeaturesPkg" selector="sorted">sorted	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted"		^self asArray sorted</body><body package="PharoCollectionsFeaturesPkg" selector="sorted:">sorted: aSortBlockOrNil	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then &lt;= is used for comparison."		^self asArray sort: aSortBlockOrNil</body></methods><methods><class-id>Core.Collection</class-id> <category>math</category><body package="PharoCollectionsFeaturesPkg" selector="sum:">sum: aBlock	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample := aBlock value: self anyOne.	sum := self inject: sample into: [ :previousValue :each |  previousValue + (aBlock value: each) ].	^ sum - sample</body></methods><methods><class-id>Core.LinkedList class</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="streamSpecies">streamSpecies	^ Array</body></methods><methods><class-id>Core.LinkedList</class-id> <category>removing</category><body package="PharoCollectionsFeaturesPkg" selector="removeAll">removeAll	"Implementation note: this has to be fast"	firstLink := lastLink := nil</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="PharoCollectionsFeaturesPkg" selector="as:">as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self</body><body package="PharoCollectionsFeaturesPkg" selector="asLink">asLink	"Answer a string that represents the receiver."	^ LinkValue value: self</body></methods><methods><class-id>Core.Object</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="putOn:">putOn: aStream	aStream nextPut: self</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="PharoCollectionsFeaturesPkg" selector="rtfmEquals:">rtfmEquals: anObject 	"Stands for ""Read The Manual Equals"". Here is the manual: 		This #rtfmEquals: has for its goal to give a consistent implementation of #= and #equals: without changing or impacting their current behavior.		A good implementation should be an object equality and not a pointer equality as is currently the case. (E.g. in dictionary, you should use equals: for this purpose. = gives you a ==).		Please use me and implement me in subclasses with respect to the above description but only if you know what you are doing ;).		Implementation advice: use #rtfmEquals: instead of #= in your implementations"	^self = anObject</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="PharoCollectionsFeaturesPkg" selector="codePoint:">codePoint: anInteger 	"Just for ANSI Compliance"		^self value: anInteger</body></methods><methods><class-id>Core.Character</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="asciiValue">asciiValue	^self asInteger</body><body package="PharoCollectionsFeaturesPkg" selector="codePoint">codePoint	"Just for ANSI Compliance"		^self asciiValue</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="flatCollect:">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"		^ self flatCollect: aBlock as: OrderedCollection</body></methods><methods><class-id>Core.Link</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="asLink">asLink	^self</body></methods><methods><class-id>Core.Symbol class</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="streamSpecies">streamSpecies	^ String</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="PharoCollectionsFeaturesPkg" selector="asMutator">asMutator	"Return a setter message from a getter message. For example,	#name asMutator returns #name:	return self if it is already a setter"	self isKeyword ifTrue: [^self].	^(self copyWith: $:) asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>testing</category><body package="PharoCollectionsFeaturesPkg" selector="isUnary">isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence = 1</body></methods><methods><class-id>Core.Symbol</class-id> <category>sorting</category><body package="PharoCollectionsFeaturesPkg" selector="sorted:">sorted: aSortBlockOrNil	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then &lt;= is used for comparison. We convert the symbol to an array because symbols can't be changed."		^self asArray sort: aSortBlockOrNil</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="PharoCollectionsFeaturesPkg" selector="new:streamContents:">new: newSize streamContents: blockWithArg 	| stream |	stream := WriteStream on: (self streamSpecies new: newSize). 	blockWithArg value: stream.	^stream contents</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="streamContents:">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body><body package="PharoCollectionsFeaturesPkg" selector="streamSpecies">streamSpecies	"I return the class that is used for streaming. If override consider overriding #new:streamContents:"	^ self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="PharoCollectionsFeaturesPkg" selector="allButFirst">allButFirst	"Answer all but the first element of the receiver."	^self allButFirst: 1</body><body package="PharoCollectionsFeaturesPkg" selector="allButLast">allButLast	"Answer all but the first element of the receiver."	^self allButLast: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="allButLastDo:">allButLastDo: block	1 to: self size - 1 do:		[:index | block value: (self at: index)]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="anyOne">anyOne	^ self first</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="PharoCollectionsFeaturesPkg" selector="beginsWith:">beginsWith: aSequenceableCollection	"Answer true if the receiver starts with the argument collection"	(aSequenceableCollection isEmpty or: [self size &lt; aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection doWithIndex: [:each :index | (self at: index) ~= each ifTrue: [^false]].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="detectIndex:">detectIndex: aBlock	^ self detectIndex: aBlock ifNone: [ self notFoundError ]</body><body package="PharoCollectionsFeaturesPkg" selector="detectIndex:ifNone:">detectIndex: aBlock ifNone: exceptionBlock	self doWithIndex: [:each :index | (aBlock value: each) ifTrue: [^ index]].	^ exceptionBlock value</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="PharoCollectionsFeaturesPkg" selector="endsWith:">endsWith: aSequenceableCollection	"Answer true if the receiver ends with the argument collection"		| start |	(aSequenceableCollection isEmpty or: [self size &lt; aSequenceableCollection size]) ifTrue: [^false].	start := self size - aSequenceableCollection size.	aSequenceableCollection doWithIndex: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="flatCollect:">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. optimized version for Sequencable Collection and subclasses	implementing #writeStream"		| stream |	self isEmpty ifTrue: [ ^ self copy ].	stream := (self species new: 0) writeStream.	self do: [ :each | stream nextPutAll: (aBlock value: each) ].	^ stream contents</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>comparing</category><body package="PharoCollectionsFeaturesPkg" selector="hasEqualElements:">hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	((size := self size) rtfmEquals: otherCollection size) ifFalse: [^ false].	1 to: size do:		[:index |		((self at: index) rtfmEquals: (otherCollection at: index)) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="putOn:">putOn: aStream	self do: [ :each | each putOn: aStream ]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>comparing</category><body package="PharoCollectionsFeaturesPkg" selector="rtfmEquals:">rtfmEquals: otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ self hasEqualElements: otherCollection</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>sorting</category><body package="PharoCollectionsFeaturesPkg" selector="sort:">sort: aSortBlock	"Sort the receiver in-place in reversed order using aSortBlock, which can be one	of: a closure with two agrument, a closure with one argument or a symbol."	SequenceableCollectionSorter sort: self using: [ :a :b | aSortBlock cull: a cull: b ].	^self</body><body package="PharoCollectionsFeaturesPkg" selector="sorted">sorted	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted in ascending order using the #'&lt;=' operator."		^self sorted: [ :a :b| a &lt;= b ]</body><body package="PharoCollectionsFeaturesPkg" selector="sorted:">sorted: aSortBlockOrNil	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then &lt;= is used for comparison."		^self copy sort: aSortBlockOrNil</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="withIndexCollect:">withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result</body></methods><methods><class-id>Core.ArrayedCollection</class-id> <category>removing</category><body package="PharoCollectionsFeaturesPkg" selector="removeAll">removeAll	self shouldNotImplement</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>instance creation</category><body package="PharoCollectionsFeaturesPkg" selector="newFrom:">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body><body package="PharoCollectionsFeaturesPkg" selector="newFromPairs:">newFromPairs: anArray	"Answer an instance of me associating (anArray at: i) to (anArray at: i+1)	 for each odd i.  anArray must have an even number of entries."	"Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}."	| newDictionary |	newDictionary := self new: anArray size / 2.	1 to: anArray size - 1 by: 2 do: [ :i | newDictionary at: (anArray at: i) put: (anArray at: i + 1) ].	^ newDictionary</body></methods><methods><class-id>Core.Dictionary</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="difference:">difference: aCollection	"Answer the set theoretic difference of two collections. This is a specialized version for Dictionaries keeping the keys of the objects. At a slightly higher price of an additional Set to track duplicates."	| other result duplicates |		other := aCollection asSet.	duplicates := Set new.	result := self class new: self size.		self keysAndValuesDo: [ :key :value|		((other includes: value) not and: [ (duplicates includes: value) not ])			ifTrue: [ 				duplicates add: value.				result at: key put: value]].		^ result</body></methods><methods><class-id>Core.Dictionary</class-id> <category>comparing</category><body package="PharoCollectionsFeaturesPkg" selector="hash">hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size &lt;= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash</body><body package="PharoCollectionsFeaturesPkg" selector="rtfmEquals:">rtfmEquals: aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	(self size rtfmEquals: aDictionary size) ifFalse: [^false].	self associationsDo: [:assoc|		((aDictionary at: assoc key ifAbsent: [^false]) rtfmEquals: assoc value)			ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Set</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="difference:">difference: aCollection	"Answer the set theoretic difference of two collections. Optimized version for Sets where no intermediate Set is necessary"	"#(a b c d e f) difference:  #(a b z k)	=&gt; #(#f #d #e #c)		#(a b z k) difference: #(a b c d e f) 	=&gt; #(#k #z) 	"	| set |	set := self copy.	aCollection do: [ :each | set remove: each ifAbsent: [  ] ].	^ set</body><body package="PharoCollectionsFeaturesPkg" selector="intersection:">intersection: aCollection	"Answer the set theoretic intersection of two collections.	Optimized version for Sets where no intermediate Set is necessary"	| outputSet |		outputSet := self class new.		aCollection do: [ :each|		((self includes: each) and: [(outputSet includes: each) not])				ifTrue: [ outputSet add: each]].			^ outputSet</body></methods><methods><class-id>Core.Bag</class-id> <category>removing</category><body package="PharoCollectionsFeaturesPkg" selector="removeAll">removeAll	"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.	An alternative implementation preserving capacity would be to create a new contents:	self setContents: (self class contentsClass new: contents size)."		contents removeAll</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="&lt;&lt;">&lt;&lt; anObject	"A more readable, shorter alternative to #nextPutAll: that also	accepts non-Collection arguments"	anObject class == collection class		ifTrue: [ self nextPutAll: anObject ]		ifFalse: [ anObject putOn: self ]</body><body package="PharoCollectionsFeaturesPkg" selector="lf">lf	self nextPut: Character lf</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="&lt;&lt;">&lt;&lt; anObject	"A more readable, shorter alternative to #nextPutAll: that also	accepts non-Collection arguments" 	anObject putOn: self</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="PharoCollectionsFeaturesPkg" selector="yyyymmdd">yyyymmdd 	"Format the date in ISO 8601 standard like '2002-10-22'	The result is of fixed size 10 characters long.."  	^ String new: 10 streamContents: [ :aStream |		self printOn: aStream format: #(3 2 1 $- 1 1 2) ]</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="streamSpecies">streamSpecies	^ Array</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>removing</category><body package="PharoCollectionsFeaturesPkg" selector="removeAll">removeAll	self removeAllSuchThat: [:e | true]</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="PharoCollectionsFeaturesPkg" selector="withIndexCollect:">withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection := self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (elementAndIndexBlock			value: (self basicAt: index)			value: index - firstIndex + 1)].	^ newCollection</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="includesSubstring:">includesSubstring: substring	^ substring isEmpty or: [ (self findString: substring startingAt: 1) &gt; 0 ]</body></methods><methods><class-id>Core.Interval class</class-id> <category>streaming</category><body package="PharoCollectionsFeaturesPkg" selector="streamSpecies">streamSpecies	^ Array</body></methods><methods><class-id>Core.Interval</class-id> <category>accessing</category><body package="PharoCollectionsFeaturesPkg" selector="anyOne">anyOne	"This message will fail for an empty Interval, super would not.	(2 to: 1) anyOne should fail because empty."	^self at: 1</body></methods><methods><class-id>Core.Interval</class-id> <category>sorting</category><body package="PharoCollectionsFeaturesPkg" selector="sorted">sorted	^ self increment &gt;= 0		ifTrue: [ self copy ]		ifFalse: [ self last to: self first by: self increment negated ]</body><body package="PharoCollectionsFeaturesPkg" selector="sorted:">sorted: aSortBlockOrNil	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then &lt;= is used for comparison. We convert the interval to an array because intervals can't be changed."		^self asArray sort: aSortBlockOrNil</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>private</category><body package="MethodWrappersApp" selector="realAt:">realAt: i	^self basicAt: i</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="MethodWrappersApp" selector="unwrappedMethod">unwrappedMethod	^self</body></methods><methods><class-id>Refactory.Browser.CodeTool</class-id> <category>private</category><body package="SequenceDiagram" selector="createSmalltalkContext">createSmalltalkContext	"for other browser compatibility"	| context |	context := LSmalltalkContext new.	context selectedClass: self selectedClass.	context selector: self selector.	^context</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>private</category><body package="SUnitToo" selector="testMethodTags">testMethodTags	"Any method tagged with a &lt;test&gt; pragma is considered a test selector candidate"	"&lt;uses:&gt; tags are used to compute instance specific resources for the tagged test. The argument is a symbol for the class name, or a binding reference to the same."	&lt;pragmas: #instance&gt;	^#(#test #uses:)</body><body package="SUnitToo" selector="testResourceTags">testResourceTags	"Any method tagged with a &lt;test&gt; pragma is considered a test selector candidate"	"&lt;resource:&gt; tags are used to compute instance specific resources for the tagged test. The argument is a symbol for the class name, or a binding reference to the same."	&lt;pragmas: #class&gt;	^#(#resource)</body></methods><methods><class-id>SequenceDiagram.BlockNodeProbeEditor class</class-id> <category>interface specs</category><body package="SequenceDiagram" selector="logEditorSpec">logEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #logEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Sequence Diagram Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 494 500 ) 			#max: #(#{Core.Point} 1920 1080 ) 			#bounds: #(#{Graphics.Rectangle} 503 403 997 903 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -45 1 -120 1 -15 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -45 1 -10 1 -15 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 20 0 0.5 0 ) 					#name: #Label4 					#label: 'Packages to instrument' 					#style: #'Lam-Large-Bold' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #Label1 							#label: 'File Name ' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 20 0 0 1.0 0 1.0 ) 							#name: #FieldNameInputField 							#model: #fileName ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -70 1 -250 1 -15 1 ) 						#name: #Composite1 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1.0 25 0 ) 									#name: #ActionButton1 									#callbacksSpec: 									#(#{UI.UIEventCallbackSubSpec} 										#valueChangeSelector: #disturb ) 									#model: #addToSelectedPackages 									#label: 									#(#{Kernel.UserMessage} 										#key: #AddArrow 										#defaultString: 'Add &gt;' 										#catalogID: #packages ) 									#defaultable: true ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1.0 55 0 ) 									#name: #ActionButton2 									#callbacksSpec: 									#(#{UI.UIEventCallbackSubSpec} 										#valueChangeSelector: #disturb ) 									#model: #removeFromSelectedPackages 									#label: 									#(#{Kernel.UserMessage} 										#key: #Remove 										#defaultString: '&lt; Remove' 										#catalogID: #packages ) 									#defaultable: true ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0.42616 36 0 0 0.57384 91 0 ) 								#name: #Composite4 ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.SequenceViewSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0.0 21 0 0 1.0 0 1.0 ) 									#name: #List1 									#flags: 15 									#model: #selectedPackages ) 								#(#{UI.LabelSpec} 									#layout: #(#{UI.AlignmentOrigin} 0 0.0 21 0 0 1 ) 									#name: #Label2 									#label: 									#(#{Kernel.UserMessage} 										#key: #BundleContentsC 										#defaultString: 'Selecte Packages:' 										#catalogID: #packages ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0.605485 0 0 0 1.0 0 1.0 ) 								#name: #Composite2 ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.SequenceViewSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 21 0 0 1.0 0 1.0 ) 									#name: #availablePackageView 									#flags: 15 									#callbacksSpec: 									#(#{UI.UIEventCallbackSubSpec} 										#requestValueChangeSelector: 										#okSelection: ) 									#model: #availablePackages 									#multipleSelections: true 									#selectionType: #highlight ) 								#(#{UI.LabelSpec} 									#layout: #(#{UI.AlignmentOrigin} 0 0 21 0 0 1 ) 									#name: #Label3 									#label: 									#(#{Kernel.UserMessage} 										#key: #AvailableC 										#defaultString: 'Available:' 										#catalogID: #packages ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 6 0 0 0.394515 0 1.0 ) 								#name: #Composite3 ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 44 0 -10 1 0 0.65 ) 						#name: #Composite5 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 1 0 ) 							#name: #Label5 							#label: 'Transformer' ) 						#(#{LPrettyTextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 21 0 0 1 0 1 ) 							#name: #PrettyLEDTextEditor 							#model: #transformerCode 							#tabRequiresControl: true 							#language: #LSmalltalkExpression ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 10 0.65 -10 1 -70 1 ) 						#name: #Composite6 ) ) ) ) )</body></methods><methods><class-id>LAN.LANInterface class</class-id> <category>interface specs</category><body package="LANModel" selector="originateDialog">originateDialog	"UIPainter new openOnClass: self andSelector: #originateDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Originate' 			#bounds: #(#Rectangle 301 390 587 741 ) 			#flags: 8 ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 2 0 0.5 0 ) 					#label: 'Originate a new packet' ) 				#(#LabelSpec 					#layout: #(#Point 3 30 ) 					#label: 'Originator' ) 				#(#LabelSpec 					#layout: #(#Point 3 95 ) 					#label: 'Addressee' ) 				#(#LabelSpec 					#layout: #(#Point 3 160 ) 					#label: 'Contents' ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 10 0 55 0 -10 1 80 0 ) 					#model: #originator 					#menu: #originators ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 10 0 120 0 -10 1 145 0 ) 					#model: #addressee 					#menu: #addressees ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 10 0 185 0 -10 1 -40 1 ) 					#model: #contents ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 20 0 -30 1 -50 0.5 -3 1 ) 					#model: #accept 					#label: 'Accept' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 50 0.5 -30 1 -20 1 -3 1 ) 					#model: #cancel 					#label: 'Cancel' ) ) ) )</body><body package="LANModel" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Local Area Network' 			#bounds: #(#Rectangle 189 174 816 582 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 5 0 0 0 -120 1 50 0 ) 					#label: 'Create' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 20 120 45 ) 					#model: #newWorkstation 					#label: 'Workstation' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 140 20 240 45 ) 					#model: #newNode 					#label: 'Node' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 260 20 360 45 ) 					#model: #newPrintServer 					#label: 'PrintServer' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 380 20 480 45 ) 					#model: #newFileServer 					#label: 'FileServer' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -105 1 20 0 -5 1 45 0 ) 					#name: #removeButton 					#model: #remove 					#label: 'Remove' ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 5 0 60 0 -5 1 -130 1 ) 					#name: #nodeList 					#flags: 15 					#model: #nodeList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 5 0 -110 1 ) 					#label: 'Name:' ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 5 0 -75 1 ) 					#label: 'Next Node:' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -50 0.5 -30 1 50 0.5 -5 1 ) 					#name: #originateButton 					#model: #originate 					#label: 'Originate' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 80 0 -110 1 300 0 -85 1 ) 					#name: #nodeName 					#model: #nodeName 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedNode ) 					#type: #symbol ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 80 0 -75 1 300 0 -50 1 ) 					#name: #nextNodeMenu 					#model: #nextNode 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedNode ) 					#menu: #deviceNameMenu ) ) ) )</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>probes</category><body package="SequenceDiagram" selector="addSequenceDiagramBlockProbe">addSequenceDiagramBlockProbe	&lt;menuItem: #(#intiAStart #pdp 'Generate Sequence Diagram') nameKey: #intiAStart enablement: #areProbeCommandsLegal indication: nil menu: #(#mainMenu ) position: 26.1&gt;	| probedCompiledMethod originalMethod textController ast nodeForProbing probeSpec probeIn probeOut execBlock ensureBlock newNode oldAst newParseTree selectedNode newExecBlock newEnsureBlock |	textController := self textController.	self selector ifNil: 			[^Dialog warn: #InsertIntiStartNeedsMethodSelection &lt;&lt; #pdp 						&gt;&gt; 'The "Insert Inti Start" operation is onlyvalid when a method is selected.'].	textController textHasChanged 		ifTrue: 			[^Dialog 				warn: (#IntiStartCannotBeInsertedCodeChanged &lt;&lt; #pdp 						&gt;&gt; 'A Inti Start cannot be inserted because&lt;1s&gt;     the source code has changed.' 							expandMacrosWith: (String with: Character cr))].							originalMethod := self selectedMethod.	PDPManager debugActive 		ifFalse: 			[PDPTransientWarning 				on: #ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled'].	probeSpec := (ProbeCreationSpec new)				probeClass: #Expression;				conditional: false.	probeSpec ifNil: [^self].	ast := self createSmalltalkContext buildParseTree.	oldAst := ast copy.	nodeForProbing := ast bestNodeFor: textController selectionRange.	execBlock := RBBlockNode body: nodeForProbing copy.	ensureBlock := RBBlockNode body: (RBVariableNode named: 'nil').	newNode := RBMessageNode 				receiver: execBlock				selector: #ensure:				arguments: (OrderedCollection with: ensureBlock).	nodeForProbing replaceWith: newNode.	 probedCompiledMethod := originalMethod mclass compiledMethodAt: (originalMethod mclass compile: ast formattedCode).	newParseTree := self createSmalltalkContext buildParseTree.	 originalMethod mclass compile: oldAst formattedCode.	selectedNode := ParseTreeSearcher treeMatching: newNode  formattedCode in: newParseTree.	newExecBlock := selectedNode receiver body.	newEnsureBlock := selectedNode arguments first.	probedCompiledMethod := probedCompiledMethod newFullProbedMethod.	probedCompiledMethod	ifNil: [^self].	probedCompiledMethod originalMethod: originalMethod.	(probeIn := SequenceDiagram.BlockNodeProbe onNode: nodeForProbing way: #in) 		record: (probedCompiledMethod 				probeRecordFor: (newExecBlock start to: newExecBlock start)).	(probeOut := SequenceDiagram.BlockNodeProbe onNode: ensureBlock				way: #out) record: (probedCompiledMethod 					probeRecordFor: (newEnsureBlock stop  to: newEnsureBlock stop )).	probeIn otherProbe: probeOut.	probeOut otherProbe: probeIn.	probedCompiledMethod addProbe: probeOut.	probedCompiledMethod addProbe: probeIn.	probeIn 		makeConditional: probeSpec		replacing: originalMethod		with: probedCompiledMethod.	^self</body></methods><initialize><class-id>SequenceDiagram.SequenceDiagramCreator</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>Application</name><environment>Smalltalk</environment><super>SubApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Envy Applications</category><attributes><package>EnvyKernel</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>LinkedList</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLink lastLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>DisplayActionProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionMethod actionSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProbedAnnotatedMethod</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbedCompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>DisplayProbeEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>